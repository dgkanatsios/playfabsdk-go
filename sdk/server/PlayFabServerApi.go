package server

// This code was generated by a tool. Any changes may be overwritten

import (
    "encoding/json"

    playfab "github.com/dgkanatsios/playfabsdk-go/sdk"

    "github.com/mitchellh/mapstructure"
)

// AddCharacterVirtualCurrency increments the character's balance of the specified virtual currency by the stated amount
// https://api.playfab.com/Documentation/Server/method/AddCharacterVirtualCurrency
func AddCharacterVirtualCurrency(settings *playfab.Settings, postData *AddCharacterVirtualCurrencyRequestModel, developerSecretKey string) (*ModifyCharacterVirtualCurrencyResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/AddCharacterVirtualCurrency", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &ModifyCharacterVirtualCurrencyResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// AddFriend adds the Friend user to the friendlist of the user with PlayFabId. At least one of
// FriendPlayFabId,FriendUsername,FriendEmail, or FriendTitleDisplayName should be initialized.
// https://api.playfab.com/Documentation/Server/method/AddFriend
func AddFriend(settings *playfab.Settings, postData *AddFriendRequestModel, developerSecretKey string) (*EmptyResponseModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/AddFriend", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// AddGenericID adds the specified generic service identifier to the player's PlayFab account. This is designed to allow for a PlayFab
// ID lookup of any arbitrary service identifier a title wants to add. This identifier should never be used as
// authentication credentials, as the intent is that it is easily accessible by other players.
// https://api.playfab.com/Documentation/Server/method/AddGenericID
func AddGenericID(settings *playfab.Settings, postData *AddGenericIDRequestModel, developerSecretKey string) (*EmptyResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/AddGenericID", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// AddPlayerTag adds a given tag to a player profile. The tag's namespace is automatically generated based on the source of the tag.
// https://api.playfab.com/Documentation/Server/method/AddPlayerTag
func AddPlayerTag(settings *playfab.Settings, postData *AddPlayerTagRequestModel, developerSecretKey string) (*AddPlayerTagResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/AddPlayerTag", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &AddPlayerTagResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// AddSharedGroupMembers adds users to the set of those able to update both the shared data, as well as the set of users in the group. Only users
// in the group (and the server) can add new members. Shared Groups are designed for sharing data between a very small
// number of players, please see our guide: https://api.playfab.com/docs/tutorials/landing-players/shared-groups
// https://api.playfab.com/Documentation/Server/method/AddSharedGroupMembers
func AddSharedGroupMembers(settings *playfab.Settings, postData *AddSharedGroupMembersRequestModel, developerSecretKey string) (*AddSharedGroupMembersResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/AddSharedGroupMembers", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &AddSharedGroupMembersResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// AddUserVirtualCurrency increments the user's balance of the specified virtual currency by the stated amount
// https://api.playfab.com/Documentation/Server/method/AddUserVirtualCurrency
func AddUserVirtualCurrency(settings *playfab.Settings, postData *AddUserVirtualCurrencyRequestModel, developerSecretKey string) (*ModifyUserVirtualCurrencyResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/AddUserVirtualCurrency", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &ModifyUserVirtualCurrencyResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// AuthenticateSessionTicket validated a client's session ticket, and if successful, returns details for that user
// https://api.playfab.com/Documentation/Server/method/AuthenticateSessionTicket
func AuthenticateSessionTicket(settings *playfab.Settings, postData *AuthenticateSessionTicketRequestModel, developerSecretKey string) (*AuthenticateSessionTicketResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/AuthenticateSessionTicket", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &AuthenticateSessionTicketResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// AwardSteamAchievement awards the specified users the specified Steam achievements
// https://api.playfab.com/Documentation/Server/method/AwardSteamAchievement
func AwardSteamAchievement(settings *playfab.Settings, postData *AwardSteamAchievementRequestModel, developerSecretKey string) (*AwardSteamAchievementResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/AwardSteamAchievement", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &AwardSteamAchievementResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// BanUsers bans users by PlayFab ID with optional IP address, or MAC address for the provided game.
// https://api.playfab.com/Documentation/Server/method/BanUsers
func BanUsers(settings *playfab.Settings, postData *BanUsersRequestModel, developerSecretKey string) (*BanUsersResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/BanUsers", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &BanUsersResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ConsumeItem consume uses of a consumable item. When all uses are consumed, it will be removed from the player's inventory.
// https://api.playfab.com/Documentation/Server/method/ConsumeItem
func ConsumeItem(settings *playfab.Settings, postData *ConsumeItemRequestModel, developerSecretKey string) (*ConsumeItemResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/ConsumeItem", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &ConsumeItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateSharedGroup requests the creation of a shared group object, containing key/value pairs which may be updated by all members of the
// group. When created by a server, the group will initially have no members. Shared Groups are designed for sharing data
// between a very small number of players, please see our guide:
// https://api.playfab.com/docs/tutorials/landing-players/shared-groups
// https://api.playfab.com/Documentation/Server/method/CreateSharedGroup
func CreateSharedGroup(settings *playfab.Settings, postData *CreateSharedGroupRequestModel, developerSecretKey string) (*CreateSharedGroupResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/CreateSharedGroup", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &CreateSharedGroupResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeleteCharacterFromUser deletes the specific character ID from the specified user.
// https://api.playfab.com/Documentation/Server/method/DeleteCharacterFromUser
func DeleteCharacterFromUser(settings *playfab.Settings, postData *DeleteCharacterFromUserRequestModel, developerSecretKey string) (*DeleteCharacterFromUserResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/DeleteCharacterFromUser", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &DeleteCharacterFromUserResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeletePlayer removes a user's player account from a title and deletes all associated data
// https://api.playfab.com/Documentation/Server/method/DeletePlayer
func DeletePlayer(settings *playfab.Settings, postData *DeletePlayerRequestModel, developerSecretKey string) (*DeletePlayerResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/DeletePlayer", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &DeletePlayerResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeletePushNotificationTemplate deletes push notification template for title
// https://api.playfab.com/Documentation/Server/method/DeletePushNotificationTemplate
func DeletePushNotificationTemplate(settings *playfab.Settings, postData *DeletePushNotificationTemplateRequestModel, developerSecretKey string) (*DeletePushNotificationTemplateResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/DeletePushNotificationTemplate", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &DeletePushNotificationTemplateResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeleteSharedGroup deletes a shared group, freeing up the shared group ID to be reused for a new group. Shared Groups are designed for
// sharing data between a very small number of players, please see our guide:
// https://api.playfab.com/docs/tutorials/landing-players/shared-groups
// https://api.playfab.com/Documentation/Server/method/DeleteSharedGroup
func DeleteSharedGroup(settings *playfab.Settings, postData *DeleteSharedGroupRequestModel, developerSecretKey string) (*EmptyResponseModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/DeleteSharedGroup", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeregisterGame inform the matchmaker that a Game Server Instance is removed.
// https://api.playfab.com/Documentation/Server/method/DeregisterGame
func DeregisterGame(settings *playfab.Settings, postData *DeregisterGameRequestModel, developerSecretKey string) (*DeregisterGameResponseModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/DeregisterGame", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &DeregisterGameResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// EvaluateRandomResultTable returns the result of an evaluation of a Random Result Table - the ItemId from the game Catalog which would have been
// added to the player inventory, if the Random Result Table were added via a Bundle or a call to UnlockContainer.
// https://api.playfab.com/Documentation/Server/method/EvaluateRandomResultTable
func EvaluateRandomResultTable(settings *playfab.Settings, postData *EvaluateRandomResultTableRequestModel, developerSecretKey string) (*EvaluateRandomResultTableResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/EvaluateRandomResultTable", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &EvaluateRandomResultTableResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ExecuteCloudScript executes a CloudScript function, with the 'currentPlayerId' variable set to the specified PlayFabId parameter value.
// https://api.playfab.com/Documentation/Server/method/ExecuteCloudScript
func ExecuteCloudScript(settings *playfab.Settings, postData *ExecuteCloudScriptServerRequestModel, developerSecretKey string) (*ExecuteCloudScriptResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/ExecuteCloudScript", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &ExecuteCloudScriptResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetAllSegments retrieves an array of player segment definitions. Results from this can be used in subsequent API calls such as
// GetPlayersInSegment which requires a Segment ID. While segment names can change the ID for that segment will not change.
// https://api.playfab.com/Documentation/Server/method/GetAllSegments
func GetAllSegments(settings *playfab.Settings, postData *GetAllSegmentsRequestModel, developerSecretKey string) (*GetAllSegmentsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetAllSegments", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetAllSegmentsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetAllUsersCharacters lists all of the characters that belong to a specific user. CharacterIds are not globally unique; characterId must be
// evaluated with the parent PlayFabId to guarantee uniqueness.
// https://api.playfab.com/Documentation/Server/method/GetAllUsersCharacters
func GetAllUsersCharacters(settings *playfab.Settings, postData *ListUsersCharactersRequestModel, developerSecretKey string) (*ListUsersCharactersResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetAllUsersCharacters", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &ListUsersCharactersResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetCatalogItems retrieves the specified version of the title's catalog of virtual goods, including all defined properties
// https://api.playfab.com/Documentation/Server/method/GetCatalogItems
func GetCatalogItems(settings *playfab.Settings, postData *GetCatalogItemsRequestModel, developerSecretKey string) (*GetCatalogItemsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetCatalogItems", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetCatalogItemsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetCharacterData retrieves the title-specific custom data for the user which is readable and writable by the client
// https://api.playfab.com/Documentation/Server/method/GetCharacterData
func GetCharacterData(settings *playfab.Settings, postData *GetCharacterDataRequestModel, developerSecretKey string) (*GetCharacterDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetCharacterData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetCharacterDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetCharacterInternalData retrieves the title-specific custom data for the user's character which cannot be accessed by the client
// https://api.playfab.com/Documentation/Server/method/GetCharacterInternalData
func GetCharacterInternalData(settings *playfab.Settings, postData *GetCharacterDataRequestModel, developerSecretKey string) (*GetCharacterDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetCharacterInternalData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetCharacterDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetCharacterInventory retrieves the specified character's current inventory of virtual goods
// https://api.playfab.com/Documentation/Server/method/GetCharacterInventory
func GetCharacterInventory(settings *playfab.Settings, postData *GetCharacterInventoryRequestModel, developerSecretKey string) (*GetCharacterInventoryResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetCharacterInventory", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetCharacterInventoryResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetCharacterLeaderboard retrieves a list of ranked characters for the given statistic, starting from the indicated point in the leaderboard
// https://api.playfab.com/Documentation/Server/method/GetCharacterLeaderboard
func GetCharacterLeaderboard(settings *playfab.Settings, postData *GetCharacterLeaderboardRequestModel, developerSecretKey string) (*GetCharacterLeaderboardResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetCharacterLeaderboard", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetCharacterLeaderboardResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetCharacterReadOnlyData retrieves the title-specific custom data for the user's character which can only be read by the client
// https://api.playfab.com/Documentation/Server/method/GetCharacterReadOnlyData
func GetCharacterReadOnlyData(settings *playfab.Settings, postData *GetCharacterDataRequestModel, developerSecretKey string) (*GetCharacterDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetCharacterReadOnlyData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetCharacterDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetCharacterStatistics retrieves the details of all title-specific statistics for the specific character
// https://api.playfab.com/Documentation/Server/method/GetCharacterStatistics
func GetCharacterStatistics(settings *playfab.Settings, postData *GetCharacterStatisticsRequestModel, developerSecretKey string) (*GetCharacterStatisticsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetCharacterStatistics", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetCharacterStatisticsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetContentDownloadUrl this API retrieves a pre-signed URL for accessing a content file for the title. A subsequent HTTP GET to the returned
// URL will attempt to download the content. A HEAD query to the returned URL will attempt to retrieve the metadata of the
// content. Note that a successful result does not guarantee the existence of this content - if it has not been uploaded,
// the query to retrieve the data will fail. See this post for more information:
// https://community.playfab.com/hc/en-us/community/posts/205469488-How-to-upload-files-to-PlayFab-s-Content-Service. Also,
// please be aware that the Content service is specifically PlayFab's CDN offering, for which standard CDN rates apply.
// https://api.playfab.com/Documentation/Server/method/GetContentDownloadUrl
func GetContentDownloadUrl(settings *playfab.Settings, postData *GetContentDownloadUrlRequestModel, developerSecretKey string) (*GetContentDownloadUrlResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetContentDownloadUrl", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetContentDownloadUrlResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetFriendLeaderboard retrieves a list of ranked friends of the given player for the given statistic, starting from the indicated point in the
// leaderboard
// https://api.playfab.com/Documentation/Server/method/GetFriendLeaderboard
func GetFriendLeaderboard(settings *playfab.Settings, postData *GetFriendLeaderboardRequestModel, developerSecretKey string) (*GetLeaderboardResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetFriendLeaderboard", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetLeaderboardResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetFriendsList retrieves the current friends for the user with PlayFabId, constrained to users who have PlayFab accounts. Friends from
// linked accounts (Facebook, Steam) are also included. You may optionally exclude some linked services' friends.
// https://api.playfab.com/Documentation/Server/method/GetFriendsList
func GetFriendsList(settings *playfab.Settings, postData *GetFriendsListRequestModel, developerSecretKey string) (*GetFriendsListResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetFriendsList", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetFriendsListResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetLeaderboard retrieves a list of ranked users for the given statistic, starting from the indicated point in the leaderboard
// https://api.playfab.com/Documentation/Server/method/GetLeaderboard
func GetLeaderboard(settings *playfab.Settings, postData *GetLeaderboardRequestModel, developerSecretKey string) (*GetLeaderboardResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetLeaderboard", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetLeaderboardResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetLeaderboardAroundCharacter retrieves a list of ranked characters for the given statistic, centered on the requested user
// https://api.playfab.com/Documentation/Server/method/GetLeaderboardAroundCharacter
func GetLeaderboardAroundCharacter(settings *playfab.Settings, postData *GetLeaderboardAroundCharacterRequestModel, developerSecretKey string) (*GetLeaderboardAroundCharacterResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetLeaderboardAroundCharacter", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetLeaderboardAroundCharacterResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetLeaderboardAroundUser retrieves a list of ranked users for the given statistic, centered on the currently signed-in user
// https://api.playfab.com/Documentation/Server/method/GetLeaderboardAroundUser
func GetLeaderboardAroundUser(settings *playfab.Settings, postData *GetLeaderboardAroundUserRequestModel, developerSecretKey string) (*GetLeaderboardAroundUserResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetLeaderboardAroundUser", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetLeaderboardAroundUserResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetLeaderboardForUserCharacters retrieves a list of all of the user's characters for the given statistic.
// https://api.playfab.com/Documentation/Server/method/GetLeaderboardForUserCharacters
func GetLeaderboardForUserCharacters(settings *playfab.Settings, postData *GetLeaderboardForUsersCharactersRequestModel, developerSecretKey string) (*GetLeaderboardForUsersCharactersResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetLeaderboardForUserCharacters", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetLeaderboardForUsersCharactersResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetPlayerCombinedInfo returns whatever info is requested in the response for the user. Note that PII (like email address, facebook id) may be
// returned. All parameters default to false.
// https://api.playfab.com/Documentation/Server/method/GetPlayerCombinedInfo
func GetPlayerCombinedInfo(settings *playfab.Settings, postData *GetPlayerCombinedInfoRequestModel, developerSecretKey string) (*GetPlayerCombinedInfoResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetPlayerCombinedInfo", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetPlayerCombinedInfoResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetPlayerProfile retrieves the player's profile
// https://api.playfab.com/Documentation/Server/method/GetPlayerProfile
func GetPlayerProfile(settings *playfab.Settings, postData *GetPlayerProfileRequestModel, developerSecretKey string) (*GetPlayerProfileResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetPlayerProfile", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetPlayerProfileResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetPlayerSegments list all segments that a player currently belongs to at this moment in time.
// https://api.playfab.com/Documentation/Server/method/GetPlayerSegments
func GetPlayerSegments(settings *playfab.Settings, postData *GetPlayersSegmentsRequestModel, developerSecretKey string) (*GetPlayerSegmentsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetPlayerSegments", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetPlayerSegmentsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetPlayersInSegment allows for paging through all players in a given segment. This API creates a snapshot of all player profiles that match
// the segment definition at the time of its creation and lives through the Total Seconds to Live, refreshing its life span
// on each subsequent use of the Continuation Token. Profiles that change during the course of paging will not be reflected
// in the results. AB Test segments are currently not supported by this operation.
// https://api.playfab.com/Documentation/Server/method/GetPlayersInSegment
func GetPlayersInSegment(settings *playfab.Settings, postData *GetPlayersInSegmentRequestModel, developerSecretKey string) (*GetPlayersInSegmentResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetPlayersInSegment", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetPlayersInSegmentResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetPlayerStatistics retrieves the current version and values for the indicated statistics, for the local player.
// https://api.playfab.com/Documentation/Server/method/GetPlayerStatistics
func GetPlayerStatistics(settings *playfab.Settings, postData *GetPlayerStatisticsRequestModel, developerSecretKey string) (*GetPlayerStatisticsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetPlayerStatistics", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetPlayerStatisticsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetPlayerStatisticVersions retrieves the information on the available versions of the specified statistic.
// https://api.playfab.com/Documentation/Server/method/GetPlayerStatisticVersions
func GetPlayerStatisticVersions(settings *playfab.Settings, postData *GetPlayerStatisticVersionsRequestModel, developerSecretKey string) (*GetPlayerStatisticVersionsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetPlayerStatisticVersions", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetPlayerStatisticVersionsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetPlayerTags get all tags with a given Namespace (optional) from a player profile.
// https://api.playfab.com/Documentation/Server/method/GetPlayerTags
func GetPlayerTags(settings *playfab.Settings, postData *GetPlayerTagsRequestModel, developerSecretKey string) (*GetPlayerTagsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetPlayerTags", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetPlayerTagsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetPlayFabIDsFromFacebookIDs retrieves the unique PlayFab identifiers for the given set of Facebook identifiers.
// https://api.playfab.com/Documentation/Server/method/GetPlayFabIDsFromFacebookIDs
func GetPlayFabIDsFromFacebookIDs(settings *playfab.Settings, postData *GetPlayFabIDsFromFacebookIDsRequestModel, developerSecretKey string) (*GetPlayFabIDsFromFacebookIDsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetPlayFabIDsFromFacebookIDs", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetPlayFabIDsFromFacebookIDsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetPlayFabIDsFromFacebookInstantGamesIds retrieves the unique PlayFab identifiers for the given set of Facebook Instant Games identifiers.
// https://api.playfab.com/Documentation/Server/method/GetPlayFabIDsFromFacebookInstantGamesIds
func GetPlayFabIDsFromFacebookInstantGamesIds(settings *playfab.Settings, postData *GetPlayFabIDsFromFacebookInstantGamesIdsRequestModel, developerSecretKey string) (*GetPlayFabIDsFromFacebookInstantGamesIdsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetPlayFabIDsFromFacebookInstantGamesIds", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetPlayFabIDsFromFacebookInstantGamesIdsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetPlayFabIDsFromGenericIDs retrieves the unique PlayFab identifiers for the given set of generic service identifiers. A generic identifier is the
// service name plus the service-specific ID for the player, as specified by the title when the generic identifier was
// added to the player account.
// https://api.playfab.com/Documentation/Server/method/GetPlayFabIDsFromGenericIDs
func GetPlayFabIDsFromGenericIDs(settings *playfab.Settings, postData *GetPlayFabIDsFromGenericIDsRequestModel, developerSecretKey string) (*GetPlayFabIDsFromGenericIDsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetPlayFabIDsFromGenericIDs", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetPlayFabIDsFromGenericIDsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetPlayFabIDsFromNintendoSwitchDeviceIds retrieves the unique PlayFab identifiers for the given set of Nintendo Switch Device identifiers.
// https://api.playfab.com/Documentation/Server/method/GetPlayFabIDsFromNintendoSwitchDeviceIds
func GetPlayFabIDsFromNintendoSwitchDeviceIds(settings *playfab.Settings, postData *GetPlayFabIDsFromNintendoSwitchDeviceIdsRequestModel, developerSecretKey string) (*GetPlayFabIDsFromNintendoSwitchDeviceIdsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetPlayFabIDsFromNintendoSwitchDeviceIds", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetPlayFabIDsFromNintendoSwitchDeviceIdsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetPlayFabIDsFromPSNAccountIDs retrieves the unique PlayFab identifiers for the given set of PlayStation Network identifiers.
// https://api.playfab.com/Documentation/Server/method/GetPlayFabIDsFromPSNAccountIDs
func GetPlayFabIDsFromPSNAccountIDs(settings *playfab.Settings, postData *GetPlayFabIDsFromPSNAccountIDsRequestModel, developerSecretKey string) (*GetPlayFabIDsFromPSNAccountIDsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetPlayFabIDsFromPSNAccountIDs", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetPlayFabIDsFromPSNAccountIDsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetPlayFabIDsFromSteamIDs retrieves the unique PlayFab identifiers for the given set of Steam identifiers. The Steam identifiers are the profile
// IDs for the user accounts, available as SteamId in the Steamworks Community API calls.
// https://api.playfab.com/Documentation/Server/method/GetPlayFabIDsFromSteamIDs
func GetPlayFabIDsFromSteamIDs(settings *playfab.Settings, postData *GetPlayFabIDsFromSteamIDsRequestModel, developerSecretKey string) (*GetPlayFabIDsFromSteamIDsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetPlayFabIDsFromSteamIDs", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetPlayFabIDsFromSteamIDsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetPlayFabIDsFromXboxLiveIDs retrieves the unique PlayFab identifiers for the given set of XboxLive identifiers.
// https://api.playfab.com/Documentation/Server/method/GetPlayFabIDsFromXboxLiveIDs
func GetPlayFabIDsFromXboxLiveIDs(settings *playfab.Settings, postData *GetPlayFabIDsFromXboxLiveIDsRequestModel, developerSecretKey string) (*GetPlayFabIDsFromXboxLiveIDsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetPlayFabIDsFromXboxLiveIDs", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetPlayFabIDsFromXboxLiveIDsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetPublisherData retrieves the key-value store of custom publisher settings
// https://api.playfab.com/Documentation/Server/method/GetPublisherData
func GetPublisherData(settings *playfab.Settings, postData *GetPublisherDataRequestModel, developerSecretKey string) (*GetPublisherDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetPublisherData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetPublisherDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetRandomResultTables retrieves the configuration information for the specified random results tables for the title, including all ItemId
// values and weights
// https://api.playfab.com/Documentation/Server/method/GetRandomResultTables
func GetRandomResultTables(settings *playfab.Settings, postData *GetRandomResultTablesRequestModel, developerSecretKey string) (*GetRandomResultTablesResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetRandomResultTables", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetRandomResultTablesResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetServerCustomIDsFromPlayFabIDs retrieves the associated PlayFab account identifiers for the given set of server custom identifiers.
// https://api.playfab.com/Documentation/Server/method/GetServerCustomIDsFromPlayFabIDs
func GetServerCustomIDsFromPlayFabIDs(settings *playfab.Settings, postData *GetServerCustomIDsFromPlayFabIDsRequestModel, developerSecretKey string) (*GetServerCustomIDsFromPlayFabIDsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetServerCustomIDsFromPlayFabIDs", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetServerCustomIDsFromPlayFabIDsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetSharedGroupData retrieves data stored in a shared group object, as well as the list of members in the group. The server can access all
// public and private group data. Shared Groups are designed for sharing data between a very small number of players,
// please see our guide: https://api.playfab.com/docs/tutorials/landing-players/shared-groups
// https://api.playfab.com/Documentation/Server/method/GetSharedGroupData
func GetSharedGroupData(settings *playfab.Settings, postData *GetSharedGroupDataRequestModel, developerSecretKey string) (*GetSharedGroupDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetSharedGroupData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetSharedGroupDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetTime retrieves the current server time
// https://api.playfab.com/Documentation/Server/method/GetTime
func GetTime(settings *playfab.Settings, postData *GetTimeRequestModel, developerSecretKey string) (*GetTimeResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetTime", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetTimeResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetTitleData retrieves the key-value store of custom title settings
// https://api.playfab.com/Documentation/Server/method/GetTitleData
func GetTitleData(settings *playfab.Settings, postData *GetTitleDataRequestModel, developerSecretKey string) (*GetTitleDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetTitleData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetTitleDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetTitleInternalData retrieves the key-value store of custom internal title settings
// https://api.playfab.com/Documentation/Server/method/GetTitleInternalData
func GetTitleInternalData(settings *playfab.Settings, postData *GetTitleDataRequestModel, developerSecretKey string) (*GetTitleDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetTitleInternalData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetTitleDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetTitleNews retrieves the title news feed, as configured in the developer portal
// https://api.playfab.com/Documentation/Server/method/GetTitleNews
func GetTitleNews(settings *playfab.Settings, postData *GetTitleNewsRequestModel, developerSecretKey string) (*GetTitleNewsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetTitleNews", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetTitleNewsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetUserAccountInfo retrieves the relevant details for a specified user
// https://api.playfab.com/Documentation/Server/method/GetUserAccountInfo
func GetUserAccountInfo(settings *playfab.Settings, postData *GetUserAccountInfoRequestModel, developerSecretKey string) (*GetUserAccountInfoResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetUserAccountInfo", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetUserAccountInfoResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetUserBans gets all bans for a user.
// https://api.playfab.com/Documentation/Server/method/GetUserBans
func GetUserBans(settings *playfab.Settings, postData *GetUserBansRequestModel, developerSecretKey string) (*GetUserBansResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetUserBans", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetUserBansResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetUserData retrieves the title-specific custom data for the user which is readable and writable by the client
// https://api.playfab.com/Documentation/Server/method/GetUserData
func GetUserData(settings *playfab.Settings, postData *GetUserDataRequestModel, developerSecretKey string) (*GetUserDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetUserData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetUserDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetUserInternalData retrieves the title-specific custom data for the user which cannot be accessed by the client
// https://api.playfab.com/Documentation/Server/method/GetUserInternalData
func GetUserInternalData(settings *playfab.Settings, postData *GetUserDataRequestModel, developerSecretKey string) (*GetUserDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetUserInternalData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetUserDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetUserInventory retrieves the specified user's current inventory of virtual goods
// https://api.playfab.com/Documentation/Server/method/GetUserInventory
func GetUserInventory(settings *playfab.Settings, postData *GetUserInventoryRequestModel, developerSecretKey string) (*GetUserInventoryResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetUserInventory", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetUserInventoryResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetUserPublisherData retrieves the publisher-specific custom data for the user which is readable and writable by the client
// https://api.playfab.com/Documentation/Server/method/GetUserPublisherData
func GetUserPublisherData(settings *playfab.Settings, postData *GetUserDataRequestModel, developerSecretKey string) (*GetUserDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetUserPublisherData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetUserDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetUserPublisherInternalData retrieves the publisher-specific custom data for the user which cannot be accessed by the client
// https://api.playfab.com/Documentation/Server/method/GetUserPublisherInternalData
func GetUserPublisherInternalData(settings *playfab.Settings, postData *GetUserDataRequestModel, developerSecretKey string) (*GetUserDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetUserPublisherInternalData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetUserDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetUserPublisherReadOnlyData retrieves the publisher-specific custom data for the user which can only be read by the client
// https://api.playfab.com/Documentation/Server/method/GetUserPublisherReadOnlyData
func GetUserPublisherReadOnlyData(settings *playfab.Settings, postData *GetUserDataRequestModel, developerSecretKey string) (*GetUserDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetUserPublisherReadOnlyData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetUserDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetUserReadOnlyData retrieves the title-specific custom data for the user which can only be read by the client
// https://api.playfab.com/Documentation/Server/method/GetUserReadOnlyData
func GetUserReadOnlyData(settings *playfab.Settings, postData *GetUserDataRequestModel, developerSecretKey string) (*GetUserDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GetUserReadOnlyData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GetUserDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GrantCharacterToUser grants the specified character type to the user. CharacterIds are not globally unique; characterId must be evaluated
// with the parent PlayFabId to guarantee uniqueness.
// https://api.playfab.com/Documentation/Server/method/GrantCharacterToUser
func GrantCharacterToUser(settings *playfab.Settings, postData *GrantCharacterToUserRequestModel, developerSecretKey string) (*GrantCharacterToUserResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GrantCharacterToUser", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GrantCharacterToUserResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GrantItemsToCharacter adds the specified items to the specified character's inventory
// https://api.playfab.com/Documentation/Server/method/GrantItemsToCharacter
func GrantItemsToCharacter(settings *playfab.Settings, postData *GrantItemsToCharacterRequestModel, developerSecretKey string) (*GrantItemsToCharacterResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GrantItemsToCharacter", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GrantItemsToCharacterResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GrantItemsToUser adds the specified items to the specified user's inventory
// https://api.playfab.com/Documentation/Server/method/GrantItemsToUser
func GrantItemsToUser(settings *playfab.Settings, postData *GrantItemsToUserRequestModel, developerSecretKey string) (*GrantItemsToUserResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GrantItemsToUser", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GrantItemsToUserResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GrantItemsToUsers adds the specified items to the specified user inventories
// https://api.playfab.com/Documentation/Server/method/GrantItemsToUsers
func GrantItemsToUsers(settings *playfab.Settings, postData *GrantItemsToUsersRequestModel, developerSecretKey string) (*GrantItemsToUsersResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/GrantItemsToUsers", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &GrantItemsToUsersResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// LinkServerCustomId links the custom server identifier, generated by the title, to the user's PlayFab account.
// https://api.playfab.com/Documentation/Server/method/LinkServerCustomId
func LinkServerCustomId(settings *playfab.Settings, postData *LinkServerCustomIdRequestModel, developerSecretKey string) (*LinkServerCustomIdResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/LinkServerCustomId", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &LinkServerCustomIdResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// LinkXboxAccount links the Xbox Live account associated with the provided access code to the user's PlayFab account
// https://api.playfab.com/Documentation/Server/method/LinkXboxAccount
func LinkXboxAccount(settings *playfab.Settings, postData *LinkXboxAccountRequestModel, developerSecretKey string) (*LinkXboxAccountResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/LinkXboxAccount", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &LinkXboxAccountResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// LoginWithServerCustomId securely login a game client from an external server backend using a custom identifier for that player. Server Custom ID
// and Client Custom ID are mutually exclusive and cannot be used to retrieve the same player account.
// https://api.playfab.com/Documentation/Server/method/LoginWithServerCustomId
func LoginWithServerCustomId(settings *playfab.Settings, postData *LoginWithServerCustomIdRequestModel, developerSecretKey string) (*ServerLoginResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/LoginWithServerCustomId", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &ServerLoginResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// LoginWithXbox signs the user in using a Xbox Live Token from an external server backend, returning a session identifier that can
// subsequently be used for API calls which require an authenticated user
// https://api.playfab.com/Documentation/Server/method/LoginWithXbox
func LoginWithXbox(settings *playfab.Settings, postData *LoginWithXboxRequestModel, developerSecretKey string) (*ServerLoginResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/LoginWithXbox", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &ServerLoginResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ModifyItemUses modifies the number of remaining uses of a player's inventory item
// https://api.playfab.com/Documentation/Server/method/ModifyItemUses
func ModifyItemUses(settings *playfab.Settings, postData *ModifyItemUsesRequestModel, developerSecretKey string) (*ModifyItemUsesResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/ModifyItemUses", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &ModifyItemUsesResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// MoveItemToCharacterFromCharacter moves an item from a character's inventory into another of the users's character's inventory.
// https://api.playfab.com/Documentation/Server/method/MoveItemToCharacterFromCharacter
func MoveItemToCharacterFromCharacter(settings *playfab.Settings, postData *MoveItemToCharacterFromCharacterRequestModel, developerSecretKey string) (*MoveItemToCharacterFromCharacterResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/MoveItemToCharacterFromCharacter", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &MoveItemToCharacterFromCharacterResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// MoveItemToCharacterFromUser moves an item from a user's inventory into their character's inventory.
// https://api.playfab.com/Documentation/Server/method/MoveItemToCharacterFromUser
func MoveItemToCharacterFromUser(settings *playfab.Settings, postData *MoveItemToCharacterFromUserRequestModel, developerSecretKey string) (*MoveItemToCharacterFromUserResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/MoveItemToCharacterFromUser", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &MoveItemToCharacterFromUserResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// MoveItemToUserFromCharacter moves an item from a character's inventory into the owning user's inventory.
// https://api.playfab.com/Documentation/Server/method/MoveItemToUserFromCharacter
func MoveItemToUserFromCharacter(settings *playfab.Settings, postData *MoveItemToUserFromCharacterRequestModel, developerSecretKey string) (*MoveItemToUserFromCharacterResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/MoveItemToUserFromCharacter", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &MoveItemToUserFromCharacterResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// NotifyMatchmakerPlayerLeft informs the PlayFab match-making service that the user specified has left the Game Server Instance
// https://api.playfab.com/Documentation/Server/method/NotifyMatchmakerPlayerLeft
func NotifyMatchmakerPlayerLeft(settings *playfab.Settings, postData *NotifyMatchmakerPlayerLeftRequestModel, developerSecretKey string) (*NotifyMatchmakerPlayerLeftResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/NotifyMatchmakerPlayerLeft", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &NotifyMatchmakerPlayerLeftResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// RedeemCoupon adds the virtual goods associated with the coupon to the user's inventory. Coupons can be generated via the
// Economy->Catalogs tab in the PlayFab Game Manager.
// https://api.playfab.com/Documentation/Server/method/RedeemCoupon
func RedeemCoupon(settings *playfab.Settings, postData *RedeemCouponRequestModel, developerSecretKey string) (*RedeemCouponResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/RedeemCoupon", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &RedeemCouponResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// RedeemMatchmakerTicket validates a Game Server session ticket and returns details about the user
// https://api.playfab.com/Documentation/Server/method/RedeemMatchmakerTicket
func RedeemMatchmakerTicket(settings *playfab.Settings, postData *RedeemMatchmakerTicketRequestModel, developerSecretKey string) (*RedeemMatchmakerTicketResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/RedeemMatchmakerTicket", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &RedeemMatchmakerTicketResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// RefreshGameServerInstanceHeartbeat set the state of the indicated Game Server Instance. Also update the heartbeat for the instance.
// https://api.playfab.com/Documentation/Server/method/RefreshGameServerInstanceHeartbeat
func RefreshGameServerInstanceHeartbeat(settings *playfab.Settings, postData *RefreshGameServerInstanceHeartbeatRequestModel, developerSecretKey string) (*RefreshGameServerInstanceHeartbeatResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/RefreshGameServerInstanceHeartbeat", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &RefreshGameServerInstanceHeartbeatResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// RegisterGame inform the matchmaker that a new Game Server Instance is added.
// https://api.playfab.com/Documentation/Server/method/RegisterGame
func RegisterGame(settings *playfab.Settings, postData *RegisterGameRequestModel, developerSecretKey string) (*RegisterGameResponseModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/RegisterGame", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &RegisterGameResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// RemoveFriend removes the specified friend from the the user's friend list
// https://api.playfab.com/Documentation/Server/method/RemoveFriend
func RemoveFriend(settings *playfab.Settings, postData *RemoveFriendRequestModel, developerSecretKey string) (*EmptyResponseModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/RemoveFriend", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// RemoveGenericID removes the specified generic service identifier from the player's PlayFab account.
// https://api.playfab.com/Documentation/Server/method/RemoveGenericID
func RemoveGenericID(settings *playfab.Settings, postData *RemoveGenericIDRequestModel, developerSecretKey string) (*EmptyResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/RemoveGenericID", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// RemovePlayerTag remove a given tag from a player profile. The tag's namespace is automatically generated based on the source of the tag.
// https://api.playfab.com/Documentation/Server/method/RemovePlayerTag
func RemovePlayerTag(settings *playfab.Settings, postData *RemovePlayerTagRequestModel, developerSecretKey string) (*RemovePlayerTagResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/RemovePlayerTag", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &RemovePlayerTagResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// RemoveSharedGroupMembers removes users from the set of those able to update the shared data and the set of users in the group. Only users in the
// group can remove members. If as a result of the call, zero users remain with access, the group and its associated data
// will be deleted. Shared Groups are designed for sharing data between a very small number of players, please see our
// guide: https://api.playfab.com/docs/tutorials/landing-players/shared-groups
// https://api.playfab.com/Documentation/Server/method/RemoveSharedGroupMembers
func RemoveSharedGroupMembers(settings *playfab.Settings, postData *RemoveSharedGroupMembersRequestModel, developerSecretKey string) (*RemoveSharedGroupMembersResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/RemoveSharedGroupMembers", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &RemoveSharedGroupMembersResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ReportPlayer submit a report about a player (due to bad bahavior, etc.) on behalf of another player, so that customer service
// representatives for the title can take action concerning potentially toxic players.
// https://api.playfab.com/Documentation/Server/method/ReportPlayer
func ReportPlayer(settings *playfab.Settings, postData *ReportPlayerServerRequestModel, developerSecretKey string) (*ReportPlayerServerResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/ReportPlayer", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &ReportPlayerServerResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// RevokeAllBansForUser revoke all active bans for a user.
// https://api.playfab.com/Documentation/Server/method/RevokeAllBansForUser
func RevokeAllBansForUser(settings *playfab.Settings, postData *RevokeAllBansForUserRequestModel, developerSecretKey string) (*RevokeAllBansForUserResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/RevokeAllBansForUser", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &RevokeAllBansForUserResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// RevokeBans revoke all active bans specified with BanId.
// https://api.playfab.com/Documentation/Server/method/RevokeBans
func RevokeBans(settings *playfab.Settings, postData *RevokeBansRequestModel, developerSecretKey string) (*RevokeBansResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/RevokeBans", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &RevokeBansResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// RevokeInventoryItem revokes access to an item in a user's inventory
// https://api.playfab.com/Documentation/Server/method/RevokeInventoryItem
func RevokeInventoryItem(settings *playfab.Settings, postData *RevokeInventoryItemRequestModel, developerSecretKey string) (*RevokeInventoryResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/RevokeInventoryItem", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &RevokeInventoryResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// RevokeInventoryItems revokes access for up to 25 items across multiple users and characters.
// https://api.playfab.com/Documentation/Server/method/RevokeInventoryItems
func RevokeInventoryItems(settings *playfab.Settings, postData *RevokeInventoryItemsRequestModel, developerSecretKey string) (*RevokeInventoryItemsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/RevokeInventoryItems", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &RevokeInventoryItemsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SavePushNotificationTemplate saves push notification template for title
// https://api.playfab.com/Documentation/Server/method/SavePushNotificationTemplate
func SavePushNotificationTemplate(settings *playfab.Settings, postData *SavePushNotificationTemplateRequestModel, developerSecretKey string) (*SavePushNotificationTemplateResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/SavePushNotificationTemplate", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &SavePushNotificationTemplateResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SendCustomAccountRecoveryEmail forces an email to be sent to the registered contact email address for the user's account based on an account recovery
// email template
// https://api.playfab.com/Documentation/Server/method/SendCustomAccountRecoveryEmail
func SendCustomAccountRecoveryEmail(settings *playfab.Settings, postData *SendCustomAccountRecoveryEmailRequestModel, developerSecretKey string) (*SendCustomAccountRecoveryEmailResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/SendCustomAccountRecoveryEmail", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &SendCustomAccountRecoveryEmailResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SendEmailFromTemplate sends an email based on an email template to a player's contact email
// https://api.playfab.com/Documentation/Server/method/SendEmailFromTemplate
func SendEmailFromTemplate(settings *playfab.Settings, postData *SendEmailFromTemplateRequestModel, developerSecretKey string) (*SendEmailFromTemplateResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/SendEmailFromTemplate", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &SendEmailFromTemplateResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SendPushNotification sends an iOS/Android Push Notification to a specific user, if that user's device has been configured for Push
// Notifications in PlayFab. If a user has linked both Android and iOS devices, both will be notified.
// https://api.playfab.com/Documentation/Server/method/SendPushNotification
func SendPushNotification(settings *playfab.Settings, postData *SendPushNotificationRequestModel, developerSecretKey string) (*SendPushNotificationResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/SendPushNotification", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &SendPushNotificationResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SendPushNotificationFromTemplate sends an iOS/Android Push Notification template to a specific user, if that user's device has been configured for Push
// Notifications in PlayFab. If a user has linked both Android and iOS devices, both will be notified.
// https://api.playfab.com/Documentation/Server/method/SendPushNotificationFromTemplate
func SendPushNotificationFromTemplate(settings *playfab.Settings, postData *SendPushNotificationFromTemplateRequestModel, developerSecretKey string) (*SendPushNotificationResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/SendPushNotificationFromTemplate", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &SendPushNotificationResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SetFriendTags updates the tag list for a specified user in the friend list of another user
// https://api.playfab.com/Documentation/Server/method/SetFriendTags
func SetFriendTags(settings *playfab.Settings, postData *SetFriendTagsRequestModel, developerSecretKey string) (*EmptyResponseModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/SetFriendTags", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SetGameServerInstanceData sets the custom data of the indicated Game Server Instance
// https://api.playfab.com/Documentation/Server/method/SetGameServerInstanceData
func SetGameServerInstanceData(settings *playfab.Settings, postData *SetGameServerInstanceDataRequestModel, developerSecretKey string) (*SetGameServerInstanceDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/SetGameServerInstanceData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &SetGameServerInstanceDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SetGameServerInstanceState set the state of the indicated Game Server Instance.
// https://api.playfab.com/Documentation/Server/method/SetGameServerInstanceState
func SetGameServerInstanceState(settings *playfab.Settings, postData *SetGameServerInstanceStateRequestModel, developerSecretKey string) (*SetGameServerInstanceStateResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/SetGameServerInstanceState", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &SetGameServerInstanceStateResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SetGameServerInstanceTags set custom tags for the specified Game Server Instance
// https://api.playfab.com/Documentation/Server/method/SetGameServerInstanceTags
func SetGameServerInstanceTags(settings *playfab.Settings, postData *SetGameServerInstanceTagsRequestModel, developerSecretKey string) (*SetGameServerInstanceTagsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/SetGameServerInstanceTags", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &SetGameServerInstanceTagsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SetPlayerSecret sets the player's secret if it is not already set. Player secrets are used to sign API requests. To reset a player's
// secret use the Admin or Server API method SetPlayerSecret.
// https://api.playfab.com/Documentation/Server/method/SetPlayerSecret
func SetPlayerSecret(settings *playfab.Settings, postData *SetPlayerSecretRequestModel, developerSecretKey string) (*SetPlayerSecretResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/SetPlayerSecret", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &SetPlayerSecretResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SetPublisherData updates the key-value store of custom publisher settings
// https://api.playfab.com/Documentation/Server/method/SetPublisherData
func SetPublisherData(settings *playfab.Settings, postData *SetPublisherDataRequestModel, developerSecretKey string) (*SetPublisherDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/SetPublisherData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &SetPublisherDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SetTitleData updates the key-value store of custom title settings
// https://api.playfab.com/Documentation/Server/method/SetTitleData
func SetTitleData(settings *playfab.Settings, postData *SetTitleDataRequestModel, developerSecretKey string) (*SetTitleDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/SetTitleData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &SetTitleDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SetTitleInternalData updates the key-value store of custom title settings
// https://api.playfab.com/Documentation/Server/method/SetTitleInternalData
func SetTitleInternalData(settings *playfab.Settings, postData *SetTitleDataRequestModel, developerSecretKey string) (*SetTitleDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/SetTitleInternalData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &SetTitleDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SubtractCharacterVirtualCurrency decrements the character's balance of the specified virtual currency by the stated amount. It is possible to make a VC
// balance negative with this API.
// https://api.playfab.com/Documentation/Server/method/SubtractCharacterVirtualCurrency
func SubtractCharacterVirtualCurrency(settings *playfab.Settings, postData *SubtractCharacterVirtualCurrencyRequestModel, developerSecretKey string) (*ModifyCharacterVirtualCurrencyResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/SubtractCharacterVirtualCurrency", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &ModifyCharacterVirtualCurrencyResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SubtractUserVirtualCurrency decrements the user's balance of the specified virtual currency by the stated amount. It is possible to make a VC
// balance negative with this API.
// https://api.playfab.com/Documentation/Server/method/SubtractUserVirtualCurrency
func SubtractUserVirtualCurrency(settings *playfab.Settings, postData *SubtractUserVirtualCurrencyRequestModel, developerSecretKey string) (*ModifyUserVirtualCurrencyResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/SubtractUserVirtualCurrency", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &ModifyUserVirtualCurrencyResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UnlinkServerCustomId unlinks the custom server identifier from the user's PlayFab account.
// https://api.playfab.com/Documentation/Server/method/UnlinkServerCustomId
func UnlinkServerCustomId(settings *playfab.Settings, postData *UnlinkServerCustomIdRequestModel, developerSecretKey string) (*UnlinkServerCustomIdResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UnlinkServerCustomId", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &UnlinkServerCustomIdResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UnlinkXboxAccount unlinks the related Xbox Live account from the user's PlayFab account
// https://api.playfab.com/Documentation/Server/method/UnlinkXboxAccount
func UnlinkXboxAccount(settings *playfab.Settings, postData *UnlinkXboxAccountRequestModel, developerSecretKey string) (*UnlinkXboxAccountResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UnlinkXboxAccount", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &UnlinkXboxAccountResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UnlockContainerInstance opens a specific container (ContainerItemInstanceId), with a specific key (KeyItemInstanceId, when required), and
// returns the contents of the opened container. If the container (and key when relevant) are consumable (RemainingUses >
// 0), their RemainingUses will be decremented, consistent with the operation of ConsumeItem.
// https://api.playfab.com/Documentation/Server/method/UnlockContainerInstance
func UnlockContainerInstance(settings *playfab.Settings, postData *UnlockContainerInstanceRequestModel, developerSecretKey string) (*UnlockContainerItemResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UnlockContainerInstance", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &UnlockContainerItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UnlockContainerItem searches Player or Character inventory for any ItemInstance matching the given CatalogItemId, if necessary unlocks it
// using any appropriate key, and returns the contents of the opened container. If the container (and key when relevant)
// are consumable (RemainingUses > 0), their RemainingUses will be decremented, consistent with the operation of
// ConsumeItem.
// https://api.playfab.com/Documentation/Server/method/UnlockContainerItem
func UnlockContainerItem(settings *playfab.Settings, postData *UnlockContainerItemRequestModel, developerSecretKey string) (*UnlockContainerItemResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UnlockContainerItem", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &UnlockContainerItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateAvatarUrl update the avatar URL of the specified player
// https://api.playfab.com/Documentation/Server/method/UpdateAvatarUrl
func UpdateAvatarUrl(settings *playfab.Settings, postData *UpdateAvatarUrlRequestModel, developerSecretKey string) (*EmptyResponseModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UpdateAvatarUrl", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateBans updates information of a list of existing bans specified with Ban Ids.
// https://api.playfab.com/Documentation/Server/method/UpdateBans
func UpdateBans(settings *playfab.Settings, postData *UpdateBansRequestModel, developerSecretKey string) (*UpdateBansResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UpdateBans", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateBansResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateCharacterData updates the title-specific custom data for the user's character which is readable and writable by the client
// https://api.playfab.com/Documentation/Server/method/UpdateCharacterData
func UpdateCharacterData(settings *playfab.Settings, postData *UpdateCharacterDataRequestModel, developerSecretKey string) (*UpdateCharacterDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UpdateCharacterData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateCharacterDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateCharacterInternalData updates the title-specific custom data for the user's character which cannot be accessed by the client
// https://api.playfab.com/Documentation/Server/method/UpdateCharacterInternalData
func UpdateCharacterInternalData(settings *playfab.Settings, postData *UpdateCharacterDataRequestModel, developerSecretKey string) (*UpdateCharacterDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UpdateCharacterInternalData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateCharacterDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateCharacterReadOnlyData updates the title-specific custom data for the user's character which can only be read by the client
// https://api.playfab.com/Documentation/Server/method/UpdateCharacterReadOnlyData
func UpdateCharacterReadOnlyData(settings *playfab.Settings, postData *UpdateCharacterDataRequestModel, developerSecretKey string) (*UpdateCharacterDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UpdateCharacterReadOnlyData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateCharacterDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateCharacterStatistics updates the values of the specified title-specific statistics for the specific character
// https://api.playfab.com/Documentation/Server/method/UpdateCharacterStatistics
func UpdateCharacterStatistics(settings *playfab.Settings, postData *UpdateCharacterStatisticsRequestModel, developerSecretKey string) (*UpdateCharacterStatisticsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UpdateCharacterStatistics", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateCharacterStatisticsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdatePlayerStatistics updates the values of the specified title-specific statistics for the user
// https://api.playfab.com/Documentation/Server/method/UpdatePlayerStatistics
func UpdatePlayerStatistics(settings *playfab.Settings, postData *UpdatePlayerStatisticsRequestModel, developerSecretKey string) (*UpdatePlayerStatisticsResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UpdatePlayerStatistics", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &UpdatePlayerStatisticsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateSharedGroupData adds, updates, and removes data keys for a shared group object. If the permission is set to Public, all fields updated
// or added in this call will be readable by users not in the group. By default, data permissions are set to Private.
// Regardless of the permission setting, only members of the group (and the server) can update the data. Shared Groups are
// designed for sharing data between a very small number of players, please see our guide:
// https://api.playfab.com/docs/tutorials/landing-players/shared-groups
// https://api.playfab.com/Documentation/Server/method/UpdateSharedGroupData
func UpdateSharedGroupData(settings *playfab.Settings, postData *UpdateSharedGroupDataRequestModel, developerSecretKey string) (*UpdateSharedGroupDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UpdateSharedGroupData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateSharedGroupDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateUserData updates the title-specific custom data for the user which is readable and writable by the client
// https://api.playfab.com/Documentation/Server/method/UpdateUserData
func UpdateUserData(settings *playfab.Settings, postData *UpdateUserDataRequestModel, developerSecretKey string) (*UpdateUserDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UpdateUserData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateUserDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateUserInternalData updates the title-specific custom data for the user which cannot be accessed by the client
// https://api.playfab.com/Documentation/Server/method/UpdateUserInternalData
func UpdateUserInternalData(settings *playfab.Settings, postData *UpdateUserInternalDataRequestModel, developerSecretKey string) (*UpdateUserDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UpdateUserInternalData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateUserDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateUserInventoryItemCustomData updates the key-value pair data tagged to the specified item, which is read-only from the client.
// https://api.playfab.com/Documentation/Server/method/UpdateUserInventoryItemCustomData
func UpdateUserInventoryItemCustomData(settings *playfab.Settings, postData *UpdateUserInventoryItemDataRequestModel, developerSecretKey string) (*EmptyResponseModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UpdateUserInventoryItemCustomData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateUserPublisherData updates the publisher-specific custom data for the user which is readable and writable by the client
// https://api.playfab.com/Documentation/Server/method/UpdateUserPublisherData
func UpdateUserPublisherData(settings *playfab.Settings, postData *UpdateUserDataRequestModel, developerSecretKey string) (*UpdateUserDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UpdateUserPublisherData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateUserDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateUserPublisherInternalData updates the publisher-specific custom data for the user which cannot be accessed by the client
// https://api.playfab.com/Documentation/Server/method/UpdateUserPublisherInternalData
func UpdateUserPublisherInternalData(settings *playfab.Settings, postData *UpdateUserInternalDataRequestModel, developerSecretKey string) (*UpdateUserDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UpdateUserPublisherInternalData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateUserDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateUserPublisherReadOnlyData updates the publisher-specific custom data for the user which can only be read by the client
// https://api.playfab.com/Documentation/Server/method/UpdateUserPublisherReadOnlyData
func UpdateUserPublisherReadOnlyData(settings *playfab.Settings, postData *UpdateUserDataRequestModel, developerSecretKey string) (*UpdateUserDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UpdateUserPublisherReadOnlyData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateUserDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateUserReadOnlyData updates the title-specific custom data for the user which can only be read by the client
// https://api.playfab.com/Documentation/Server/method/UpdateUserReadOnlyData
func UpdateUserReadOnlyData(settings *playfab.Settings, postData *UpdateUserDataRequestModel, developerSecretKey string) (*UpdateUserDataResultModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/UpdateUserReadOnlyData", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateUserDataResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// WriteCharacterEvent writes a character-based event into PlayStream.
// https://api.playfab.com/Documentation/Server/method/WriteCharacterEvent
func WriteCharacterEvent(settings *playfab.Settings, postData *WriteServerCharacterEventRequestModel, developerSecretKey string) (*WriteEventResponseModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/WriteCharacterEvent", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &WriteEventResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// WritePlayerEvent writes a player-based event into PlayStream.
// https://api.playfab.com/Documentation/Server/method/WritePlayerEvent
func WritePlayerEvent(settings *playfab.Settings, postData *WriteServerPlayerEventRequestModel, developerSecretKey string) (*WriteEventResponseModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/WritePlayerEvent", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &WriteEventResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// WriteTitleEvent writes a title-based event into PlayStream.
// https://api.playfab.com/Documentation/Server/method/WriteTitleEvent
func WriteTitleEvent(settings *playfab.Settings, postData *WriteTitleEventRequestModel, developerSecretKey string) (*WriteEventResponseModel, error) {
    if developerSecretKey == "" {
        return nil, playfab.NewCustomError("developerSecretKey should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Server/WriteTitleEvent", "X-SecretKey", developerSecretKey)
    if err != nil {
        return nil, err
    }
    
    result := &WriteEventResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}



