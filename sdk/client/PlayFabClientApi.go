package client

// This code was generated by a tool. Any changes may be overwritten

import (
	"encoding/json"

	playfab "github.com/dgkanatsios/playfabsdk-go/sdk"

	"github.com/mitchellh/mapstructure"
)

// AcceptTrade accepts an open trade (one that has not yet been accepted or cancelled), if the locally signed-in player is in the
// allowed player list for the trade, or it is open to all players. If the call is successful, the offered and accepted
// items will be swapped between the two players' inventories.
// https://api.playfab.com/Documentation/Client/method/AcceptTrade
func AcceptTrade(settings *playfab.Settings, postData *AcceptTradeRequestModel, clientSessionTicket string) (*AcceptTradeResponseModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/AcceptTrade", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &AcceptTradeResponseModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// AddFriend adds the PlayFab user, based upon a match against a supplied unique identifier, to the friend list of the local user. At
// least one of FriendPlayFabId,FriendUsername,FriendEmail, or FriendTitleDisplayName should be initialized.
// https://api.playfab.com/Documentation/Client/method/AddFriend
func AddFriend(settings *playfab.Settings, postData *AddFriendRequestModel, clientSessionTicket string) (*AddFriendResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/AddFriend", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &AddFriendResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// AddGenericID adds the specified generic service identifier to the player's PlayFab account. This is designed to allow for a PlayFab
// ID lookup of any arbitrary service identifier a title wants to add. This identifier should never be used as
// authentication credentials, as the intent is that it is easily accessible by other players.
// https://api.playfab.com/Documentation/Client/method/AddGenericID
func AddGenericID(settings *playfab.Settings, postData *AddGenericIDRequestModel, clientSessionTicket string) (*AddGenericIDResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/AddGenericID", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &AddGenericIDResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// AddOrUpdateContactEmail adds or updates a contact email to the player's profile.
// https://api.playfab.com/Documentation/Client/method/AddOrUpdateContactEmail
func AddOrUpdateContactEmail(settings *playfab.Settings, postData *AddOrUpdateContactEmailRequestModel, clientSessionTicket string) (*AddOrUpdateContactEmailResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/AddOrUpdateContactEmail", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &AddOrUpdateContactEmailResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// AddSharedGroupMembers adds users to the set of those able to update both the shared data, as well as the set of users in the group. Only users
// in the group can add new members. Shared Groups are designed for sharing data between a very small number of players,
// please see our guide: https://docs.microsoft.com/gaming/playfab/features/social/groups/using-shared-group-data
// https://api.playfab.com/Documentation/Client/method/AddSharedGroupMembers
func AddSharedGroupMembers(settings *playfab.Settings, postData *AddSharedGroupMembersRequestModel, clientSessionTicket string) (*AddSharedGroupMembersResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/AddSharedGroupMembers", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &AddSharedGroupMembersResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// AddUsernamePassword adds playfab username/password auth to an existing account created via an anonymous auth method, e.g. automatic device
// ID login.
// https://api.playfab.com/Documentation/Client/method/AddUsernamePassword
func AddUsernamePassword(settings *playfab.Settings, postData *AddUsernamePasswordRequestModel, clientSessionTicket string) (*AddUsernamePasswordResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/AddUsernamePassword", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &AddUsernamePasswordResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// AddUserVirtualCurrency increments the user's balance of the specified virtual currency by the stated amount
// https://api.playfab.com/Documentation/Client/method/AddUserVirtualCurrency
func AddUserVirtualCurrency(settings *playfab.Settings, postData *AddUserVirtualCurrencyRequestModel, clientSessionTicket string) (*ModifyUserVirtualCurrencyResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/AddUserVirtualCurrency", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &ModifyUserVirtualCurrencyResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// AndroidDevicePushNotificationRegistration registers the Android device to receive push notifications
// https://api.playfab.com/Documentation/Client/method/AndroidDevicePushNotificationRegistration
func AndroidDevicePushNotificationRegistration(settings *playfab.Settings, postData *AndroidDevicePushNotificationRegistrationRequestModel, clientSessionTicket string) (*AndroidDevicePushNotificationRegistrationResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/AndroidDevicePushNotificationRegistration", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &AndroidDevicePushNotificationRegistrationResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// AttributeInstall attributes an install for advertisment.
// https://api.playfab.com/Documentation/Client/method/AttributeInstall
func AttributeInstall(settings *playfab.Settings, postData *AttributeInstallRequestModel, clientSessionTicket string) (*AttributeInstallResultModel, error) {
	// Modify advertisingIdType:  Prevents us from sending the id multiple times, and allows automated tests to determine id was sent successfully
	settings.AdvertisingIdType = settings.AdvertisingIdType + "_Successful"
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/AttributeInstall", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &AttributeInstallResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// CancelTrade cancels an open trade (one that has not yet been accepted or cancelled). Note that only the player who created the trade
// can cancel it via this API call, to prevent griefing of the trade system (cancelling trades in order to prevent other
// players from accepting them, for trades that can be claimed by more than one player).
// https://api.playfab.com/Documentation/Client/method/CancelTrade
func CancelTrade(settings *playfab.Settings, postData *CancelTradeRequestModel, clientSessionTicket string) (*CancelTradeResponseModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/CancelTrade", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &CancelTradeResponseModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// ConfirmPurchase confirms with the payment provider that the purchase was approved (if applicable) and adjusts inventory and virtual
// currency balances as appropriate
// https://api.playfab.com/Documentation/Client/method/ConfirmPurchase
func ConfirmPurchase(settings *playfab.Settings, postData *ConfirmPurchaseRequestModel, clientSessionTicket string) (*ConfirmPurchaseResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/ConfirmPurchase", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &ConfirmPurchaseResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// ConsumeItem consume uses of a consumable item. When all uses are consumed, it will be removed from the player's inventory.
// https://api.playfab.com/Documentation/Client/method/ConsumeItem
func ConsumeItem(settings *playfab.Settings, postData *ConsumeItemRequestModel, clientSessionTicket string) (*ConsumeItemResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/ConsumeItem", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &ConsumeItemResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// ConsumePSNEntitlements checks for any new consumable entitlements. If any are found, they are consumed and added as PlayFab items
// https://api.playfab.com/Documentation/Client/method/ConsumePSNEntitlements
func ConsumePSNEntitlements(settings *playfab.Settings, postData *ConsumePSNEntitlementsRequestModel, clientSessionTicket string) (*ConsumePSNEntitlementsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/ConsumePSNEntitlements", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &ConsumePSNEntitlementsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// ConsumeXboxEntitlements grants the player's current entitlements from Xbox Live, consuming all availble items in Xbox and granting them to the
// player's PlayFab inventory. This call is idempotent and will not grant previously granted items to the player.
// https://api.playfab.com/Documentation/Client/method/ConsumeXboxEntitlements
func ConsumeXboxEntitlements(settings *playfab.Settings, postData *ConsumeXboxEntitlementsRequestModel, clientSessionTicket string) (*ConsumeXboxEntitlementsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/ConsumeXboxEntitlements", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &ConsumeXboxEntitlementsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// CreateSharedGroup requests the creation of a shared group object, containing key/value pairs which may be updated by all members of the
// group. Upon creation, the current user will be the only member of the group. Shared Groups are designed for sharing data
// between a very small number of players, please see our guide:
// https://docs.microsoft.com/gaming/playfab/features/social/groups/using-shared-group-data
// https://api.playfab.com/Documentation/Client/method/CreateSharedGroup
func CreateSharedGroup(settings *playfab.Settings, postData *CreateSharedGroupRequestModel, clientSessionTicket string) (*CreateSharedGroupResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/CreateSharedGroup", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &CreateSharedGroupResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// ExecuteCloudScript executes a CloudScript function, with the 'currentPlayerId' set to the PlayFab ID of the authenticated player.
// https://api.playfab.com/Documentation/Client/method/ExecuteCloudScript
func ExecuteCloudScript(settings *playfab.Settings, postData *ExecuteCloudScriptRequestModel, clientSessionTicket string) (*ExecuteCloudScriptResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/ExecuteCloudScript", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &ExecuteCloudScriptResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetAccountInfo retrieves the user's PlayFab account details
// https://api.playfab.com/Documentation/Client/method/GetAccountInfo
func GetAccountInfo(settings *playfab.Settings, postData *GetAccountInfoRequestModel, clientSessionTicket string) (*GetAccountInfoResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetAccountInfo", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetAccountInfoResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetAllUsersCharacters lists all of the characters that belong to a specific user. CharacterIds are not globally unique; characterId must be
// evaluated with the parent PlayFabId to guarantee uniqueness.
// https://api.playfab.com/Documentation/Client/method/GetAllUsersCharacters
func GetAllUsersCharacters(settings *playfab.Settings, postData *ListUsersCharactersRequestModel, clientSessionTicket string) (*ListUsersCharactersResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetAllUsersCharacters", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &ListUsersCharactersResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetCatalogItems retrieves the specified version of the title's catalog of virtual goods, including all defined properties
// https://api.playfab.com/Documentation/Client/method/GetCatalogItems
func GetCatalogItems(settings *playfab.Settings, postData *GetCatalogItemsRequestModel, clientSessionTicket string) (*GetCatalogItemsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetCatalogItems", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetCatalogItemsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetCharacterData retrieves the title-specific custom data for the character which is readable and writable by the client
// https://api.playfab.com/Documentation/Client/method/GetCharacterData
func GetCharacterData(settings *playfab.Settings, postData *GetCharacterDataRequestModel, clientSessionTicket string) (*GetCharacterDataResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetCharacterData", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetCharacterDataResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetCharacterInventory retrieves the specified character's current inventory of virtual goods
// https://api.playfab.com/Documentation/Client/method/GetCharacterInventory
func GetCharacterInventory(settings *playfab.Settings, postData *GetCharacterInventoryRequestModel, clientSessionTicket string) (*GetCharacterInventoryResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetCharacterInventory", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetCharacterInventoryResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetCharacterLeaderboard retrieves a list of ranked characters for the given statistic, starting from the indicated point in the leaderboard
// https://api.playfab.com/Documentation/Client/method/GetCharacterLeaderboard
func GetCharacterLeaderboard(settings *playfab.Settings, postData *GetCharacterLeaderboardRequestModel, clientSessionTicket string) (*GetCharacterLeaderboardResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetCharacterLeaderboard", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetCharacterLeaderboardResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetCharacterReadOnlyData retrieves the title-specific custom data for the character which can only be read by the client
// https://api.playfab.com/Documentation/Client/method/GetCharacterReadOnlyData
func GetCharacterReadOnlyData(settings *playfab.Settings, postData *GetCharacterDataRequestModel, clientSessionTicket string) (*GetCharacterDataResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetCharacterReadOnlyData", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetCharacterDataResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetCharacterStatistics retrieves the details of all title-specific statistics for the user
// https://api.playfab.com/Documentation/Client/method/GetCharacterStatistics
func GetCharacterStatistics(settings *playfab.Settings, postData *GetCharacterStatisticsRequestModel, clientSessionTicket string) (*GetCharacterStatisticsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetCharacterStatistics", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetCharacterStatisticsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetContentDownloadUrl this API retrieves a pre-signed URL for accessing a content file for the title. A subsequent HTTP GET to the returned
// URL will attempt to download the content. A HEAD query to the returned URL will attempt to retrieve the metadata of the
// content. Note that a successful result does not guarantee the existence of this content - if it has not been uploaded,
// the query to retrieve the data will fail. See this post for more information:
// https://community.playfab.com/hc/community/posts/205469488-How-to-upload-files-to-PlayFab-s-Content-Service. Also,
// please be aware that the Content service is specifically PlayFab's CDN offering, for which standard CDN rates apply.
// https://api.playfab.com/Documentation/Client/method/GetContentDownloadUrl
func GetContentDownloadUrl(settings *playfab.Settings, postData *GetContentDownloadUrlRequestModel, clientSessionTicket string) (*GetContentDownloadUrlResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetContentDownloadUrl", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetContentDownloadUrlResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetCurrentGames get details about all current running game servers matching the given parameters.
// https://api.playfab.com/Documentation/Client/method/GetCurrentGames
func GetCurrentGames(settings *playfab.Settings, postData *CurrentGamesRequestModel, clientSessionTicket string) (*CurrentGamesResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetCurrentGames", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &CurrentGamesResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetFriendLeaderboard retrieves a list of ranked friends of the current player for the given statistic, starting from the indicated point in
// the leaderboard
// https://api.playfab.com/Documentation/Client/method/GetFriendLeaderboard
func GetFriendLeaderboard(settings *playfab.Settings, postData *GetFriendLeaderboardRequestModel, clientSessionTicket string) (*GetLeaderboardResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetFriendLeaderboard", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetLeaderboardResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetFriendLeaderboardAroundPlayer retrieves a list of ranked friends of the current player for the given statistic, centered on the requested PlayFab
// user. If PlayFabId is empty or null will return currently logged in user.
// https://api.playfab.com/Documentation/Client/method/GetFriendLeaderboardAroundPlayer
func GetFriendLeaderboardAroundPlayer(settings *playfab.Settings, postData *GetFriendLeaderboardAroundPlayerRequestModel, clientSessionTicket string) (*GetFriendLeaderboardAroundPlayerResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetFriendLeaderboardAroundPlayer", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetFriendLeaderboardAroundPlayerResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetFriendsList retrieves the current friend list for the local user, constrained to users who have PlayFab accounts. Friends from
// linked accounts (Facebook, Steam) are also included. You may optionally exclude some linked services' friends.
// https://api.playfab.com/Documentation/Client/method/GetFriendsList
func GetFriendsList(settings *playfab.Settings, postData *GetFriendsListRequestModel, clientSessionTicket string) (*GetFriendsListResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetFriendsList", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetFriendsListResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetGameServerRegions get details about the regions hosting game servers matching the given parameters.
// https://api.playfab.com/Documentation/Client/method/GetGameServerRegions
func GetGameServerRegions(settings *playfab.Settings, postData *GameServerRegionsRequestModel, clientSessionTicket string) (*GameServerRegionsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetGameServerRegions", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GameServerRegionsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetLeaderboard retrieves a list of ranked users for the given statistic, starting from the indicated point in the leaderboard
// https://api.playfab.com/Documentation/Client/method/GetLeaderboard
func GetLeaderboard(settings *playfab.Settings, postData *GetLeaderboardRequestModel, clientSessionTicket string) (*GetLeaderboardResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetLeaderboard", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetLeaderboardResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetLeaderboardAroundCharacter retrieves a list of ranked characters for the given statistic, centered on the requested Character ID
// https://api.playfab.com/Documentation/Client/method/GetLeaderboardAroundCharacter
func GetLeaderboardAroundCharacter(settings *playfab.Settings, postData *GetLeaderboardAroundCharacterRequestModel, clientSessionTicket string) (*GetLeaderboardAroundCharacterResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetLeaderboardAroundCharacter", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetLeaderboardAroundCharacterResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetLeaderboardAroundPlayer retrieves a list of ranked users for the given statistic, centered on the requested player. If PlayFabId is empty or
// null will return currently logged in user.
// https://api.playfab.com/Documentation/Client/method/GetLeaderboardAroundPlayer
func GetLeaderboardAroundPlayer(settings *playfab.Settings, postData *GetLeaderboardAroundPlayerRequestModel, clientSessionTicket string) (*GetLeaderboardAroundPlayerResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetLeaderboardAroundPlayer", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetLeaderboardAroundPlayerResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetLeaderboardForUserCharacters retrieves a list of all of the user's characters for the given statistic.
// https://api.playfab.com/Documentation/Client/method/GetLeaderboardForUserCharacters
func GetLeaderboardForUserCharacters(settings *playfab.Settings, postData *GetLeaderboardForUsersCharactersRequestModel, clientSessionTicket string) (*GetLeaderboardForUsersCharactersResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetLeaderboardForUserCharacters", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetLeaderboardForUsersCharactersResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPaymentToken for payments flows where the provider requires playfab (the fulfiller) to initiate the transaction, but the client
// completes the rest of the flow. In the Xsolla case, the token returned here will be passed to Xsolla by the client to
// create a cart. Poll GetPurchase using the returned OrderId once you've completed the payment.
// https://api.playfab.com/Documentation/Client/method/GetPaymentToken
func GetPaymentToken(settings *playfab.Settings, postData *GetPaymentTokenRequestModel, clientSessionTicket string) (*GetPaymentTokenResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPaymentToken", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPaymentTokenResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPhotonAuthenticationToken gets a Photon custom authentication token that can be used to securely join the player into a Photon room. See
// https://docs.microsoft.com/gaming/playfab/features/multiplayer/photon/quickstart for more details.
// https://api.playfab.com/Documentation/Client/method/GetPhotonAuthenticationToken
func GetPhotonAuthenticationToken(settings *playfab.Settings, postData *GetPhotonAuthenticationTokenRequestModel, clientSessionTicket string) (*GetPhotonAuthenticationTokenResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPhotonAuthenticationToken", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPhotonAuthenticationTokenResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPlayerCombinedInfo retrieves all of the user's different kinds of info.
// https://api.playfab.com/Documentation/Client/method/GetPlayerCombinedInfo
func GetPlayerCombinedInfo(settings *playfab.Settings, postData *GetPlayerCombinedInfoRequestModel, clientSessionTicket string) (*GetPlayerCombinedInfoResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPlayerCombinedInfo", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPlayerCombinedInfoResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPlayerProfile retrieves the player's profile
// https://api.playfab.com/Documentation/Client/method/GetPlayerProfile
func GetPlayerProfile(settings *playfab.Settings, postData *GetPlayerProfileRequestModel, clientSessionTicket string) (*GetPlayerProfileResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPlayerProfile", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPlayerProfileResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPlayerSegments list all segments that a player currently belongs to at this moment in time.
// https://api.playfab.com/Documentation/Client/method/GetPlayerSegments
func GetPlayerSegments(settings *playfab.Settings, postData *GetPlayerSegmentsRequestModel, clientSessionTicket string) (*GetPlayerSegmentsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPlayerSegments", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPlayerSegmentsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPlayerStatistics retrieves the indicated statistics (current version and values for all statistics, if none are specified), for the local
// player.
// https://api.playfab.com/Documentation/Client/method/GetPlayerStatistics
func GetPlayerStatistics(settings *playfab.Settings, postData *GetPlayerStatisticsRequestModel, clientSessionTicket string) (*GetPlayerStatisticsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPlayerStatistics", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPlayerStatisticsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPlayerStatisticVersions retrieves the information on the available versions of the specified statistic.
// https://api.playfab.com/Documentation/Client/method/GetPlayerStatisticVersions
func GetPlayerStatisticVersions(settings *playfab.Settings, postData *GetPlayerStatisticVersionsRequestModel, clientSessionTicket string) (*GetPlayerStatisticVersionsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPlayerStatisticVersions", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPlayerStatisticVersionsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPlayerTags get all tags with a given Namespace (optional) from a player profile.
// https://api.playfab.com/Documentation/Client/method/GetPlayerTags
func GetPlayerTags(settings *playfab.Settings, postData *GetPlayerTagsRequestModel, clientSessionTicket string) (*GetPlayerTagsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPlayerTags", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPlayerTagsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPlayerTrades gets all trades the player has either opened or accepted, optionally filtered by trade status.
// https://api.playfab.com/Documentation/Client/method/GetPlayerTrades
func GetPlayerTrades(settings *playfab.Settings, postData *GetPlayerTradesRequestModel, clientSessionTicket string) (*GetPlayerTradesResponseModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPlayerTrades", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPlayerTradesResponseModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPlayFabIDsFromFacebookIDs retrieves the unique PlayFab identifiers for the given set of Facebook identifiers.
// https://api.playfab.com/Documentation/Client/method/GetPlayFabIDsFromFacebookIDs
func GetPlayFabIDsFromFacebookIDs(settings *playfab.Settings, postData *GetPlayFabIDsFromFacebookIDsRequestModel, clientSessionTicket string) (*GetPlayFabIDsFromFacebookIDsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPlayFabIDsFromFacebookIDs", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPlayFabIDsFromFacebookIDsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPlayFabIDsFromFacebookInstantGamesIds retrieves the unique PlayFab identifiers for the given set of Facebook Instant Game identifiers.
// https://api.playfab.com/Documentation/Client/method/GetPlayFabIDsFromFacebookInstantGamesIds
func GetPlayFabIDsFromFacebookInstantGamesIds(settings *playfab.Settings, postData *GetPlayFabIDsFromFacebookInstantGamesIdsRequestModel, clientSessionTicket string) (*GetPlayFabIDsFromFacebookInstantGamesIdsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPlayFabIDsFromFacebookInstantGamesIds", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPlayFabIDsFromFacebookInstantGamesIdsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPlayFabIDsFromGameCenterIDs retrieves the unique PlayFab identifiers for the given set of Game Center identifiers (referenced in the Game Center
// Programming Guide as the Player Identifier).
// https://api.playfab.com/Documentation/Client/method/GetPlayFabIDsFromGameCenterIDs
func GetPlayFabIDsFromGameCenterIDs(settings *playfab.Settings, postData *GetPlayFabIDsFromGameCenterIDsRequestModel, clientSessionTicket string) (*GetPlayFabIDsFromGameCenterIDsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPlayFabIDsFromGameCenterIDs", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPlayFabIDsFromGameCenterIDsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPlayFabIDsFromGenericIDs retrieves the unique PlayFab identifiers for the given set of generic service identifiers. A generic identifier is the
// service name plus the service-specific ID for the player, as specified by the title when the generic identifier was
// added to the player account.
// https://api.playfab.com/Documentation/Client/method/GetPlayFabIDsFromGenericIDs
func GetPlayFabIDsFromGenericIDs(settings *playfab.Settings, postData *GetPlayFabIDsFromGenericIDsRequestModel, clientSessionTicket string) (*GetPlayFabIDsFromGenericIDsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPlayFabIDsFromGenericIDs", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPlayFabIDsFromGenericIDsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPlayFabIDsFromGoogleIDs retrieves the unique PlayFab identifiers for the given set of Google identifiers. The Google identifiers are the IDs for
// the user accounts, available as "id" in the Google+ People API calls.
// https://api.playfab.com/Documentation/Client/method/GetPlayFabIDsFromGoogleIDs
func GetPlayFabIDsFromGoogleIDs(settings *playfab.Settings, postData *GetPlayFabIDsFromGoogleIDsRequestModel, clientSessionTicket string) (*GetPlayFabIDsFromGoogleIDsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPlayFabIDsFromGoogleIDs", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPlayFabIDsFromGoogleIDsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPlayFabIDsFromKongregateIDs retrieves the unique PlayFab identifiers for the given set of Kongregate identifiers. The Kongregate identifiers are the
// IDs for the user accounts, available as "user_id" from the Kongregate API methods(ex:
// http://developers.kongregate.com/docs/client/getUserId).
// https://api.playfab.com/Documentation/Client/method/GetPlayFabIDsFromKongregateIDs
func GetPlayFabIDsFromKongregateIDs(settings *playfab.Settings, postData *GetPlayFabIDsFromKongregateIDsRequestModel, clientSessionTicket string) (*GetPlayFabIDsFromKongregateIDsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPlayFabIDsFromKongregateIDs", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPlayFabIDsFromKongregateIDsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPlayFabIDsFromNintendoSwitchDeviceIds retrieves the unique PlayFab identifiers for the given set of Nintendo Switch identifiers.
// https://api.playfab.com/Documentation/Client/method/GetPlayFabIDsFromNintendoSwitchDeviceIds
func GetPlayFabIDsFromNintendoSwitchDeviceIds(settings *playfab.Settings, postData *GetPlayFabIDsFromNintendoSwitchDeviceIdsRequestModel, clientSessionTicket string) (*GetPlayFabIDsFromNintendoSwitchDeviceIdsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPlayFabIDsFromNintendoSwitchDeviceIds", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPlayFabIDsFromNintendoSwitchDeviceIdsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPlayFabIDsFromPSNAccountIDs retrieves the unique PlayFab identifiers for the given set of PlayStation Network identifiers.
// https://api.playfab.com/Documentation/Client/method/GetPlayFabIDsFromPSNAccountIDs
func GetPlayFabIDsFromPSNAccountIDs(settings *playfab.Settings, postData *GetPlayFabIDsFromPSNAccountIDsRequestModel, clientSessionTicket string) (*GetPlayFabIDsFromPSNAccountIDsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPlayFabIDsFromPSNAccountIDs", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPlayFabIDsFromPSNAccountIDsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPlayFabIDsFromSteamIDs retrieves the unique PlayFab identifiers for the given set of Steam identifiers. The Steam identifiers are the profile
// IDs for the user accounts, available as SteamId in the Steamworks Community API calls.
// https://api.playfab.com/Documentation/Client/method/GetPlayFabIDsFromSteamIDs
func GetPlayFabIDsFromSteamIDs(settings *playfab.Settings, postData *GetPlayFabIDsFromSteamIDsRequestModel, clientSessionTicket string) (*GetPlayFabIDsFromSteamIDsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPlayFabIDsFromSteamIDs", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPlayFabIDsFromSteamIDsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPlayFabIDsFromTwitchIDs retrieves the unique PlayFab identifiers for the given set of Twitch identifiers. The Twitch identifiers are the IDs for
// the user accounts, available as "_id" from the Twitch API methods (ex:
// https://github.com/justintv/Twitch-API/blob/master/v3_resources/users.md#get-usersuser).
// https://api.playfab.com/Documentation/Client/method/GetPlayFabIDsFromTwitchIDs
func GetPlayFabIDsFromTwitchIDs(settings *playfab.Settings, postData *GetPlayFabIDsFromTwitchIDsRequestModel, clientSessionTicket string) (*GetPlayFabIDsFromTwitchIDsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPlayFabIDsFromTwitchIDs", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPlayFabIDsFromTwitchIDsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPlayFabIDsFromXboxLiveIDs retrieves the unique PlayFab identifiers for the given set of XboxLive identifiers.
// https://api.playfab.com/Documentation/Client/method/GetPlayFabIDsFromXboxLiveIDs
func GetPlayFabIDsFromXboxLiveIDs(settings *playfab.Settings, postData *GetPlayFabIDsFromXboxLiveIDsRequestModel, clientSessionTicket string) (*GetPlayFabIDsFromXboxLiveIDsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPlayFabIDsFromXboxLiveIDs", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPlayFabIDsFromXboxLiveIDsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPublisherData retrieves the key-value store of custom publisher settings
// https://api.playfab.com/Documentation/Client/method/GetPublisherData
func GetPublisherData(settings *playfab.Settings, postData *GetPublisherDataRequestModel, clientSessionTicket string) (*GetPublisherDataResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPublisherData", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPublisherDataResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetPurchase retrieves a purchase along with its current PlayFab status. Returns inventory items from the purchase that are still
// active.
// https://api.playfab.com/Documentation/Client/method/GetPurchase
func GetPurchase(settings *playfab.Settings, postData *GetPurchaseRequestModel, clientSessionTicket string) (*GetPurchaseResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetPurchase", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetPurchaseResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetSharedGroupData retrieves data stored in a shared group object, as well as the list of members in the group. Non-members of the group
// may use this to retrieve group data, including membership, but they will not receive data for keys marked as private.
// Shared Groups are designed for sharing data between a very small number of players, please see our guide:
// https://docs.microsoft.com/gaming/playfab/features/social/groups/using-shared-group-data
// https://api.playfab.com/Documentation/Client/method/GetSharedGroupData
func GetSharedGroupData(settings *playfab.Settings, postData *GetSharedGroupDataRequestModel, clientSessionTicket string) (*GetSharedGroupDataResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetSharedGroupData", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetSharedGroupDataResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetStoreItems retrieves the set of items defined for the specified store, including all prices defined
// https://api.playfab.com/Documentation/Client/method/GetStoreItems
func GetStoreItems(settings *playfab.Settings, postData *GetStoreItemsRequestModel, clientSessionTicket string) (*GetStoreItemsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetStoreItems", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetStoreItemsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetTime retrieves the current server time
// https://api.playfab.com/Documentation/Client/method/GetTime
func GetTime(settings *playfab.Settings, postData *GetTimeRequestModel, clientSessionTicket string) (*GetTimeResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetTime", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetTimeResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetTitleData retrieves the key-value store of custom title settings
// https://api.playfab.com/Documentation/Client/method/GetTitleData
func GetTitleData(settings *playfab.Settings, postData *GetTitleDataRequestModel, clientSessionTicket string) (*GetTitleDataResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetTitleData", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetTitleDataResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetTitleNews retrieves the title news feed, as configured in the developer portal
// https://api.playfab.com/Documentation/Client/method/GetTitleNews
func GetTitleNews(settings *playfab.Settings, postData *GetTitleNewsRequestModel, clientSessionTicket string) (*GetTitleNewsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetTitleNews", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetTitleNewsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetTitlePublicKey returns the title's base 64 encoded RSA CSP blob.
// https://api.playfab.com/Documentation/Client/method/GetTitlePublicKey
func GetTitlePublicKey(settings *playfab.Settings, postData *GetTitlePublicKeyRequestModel) (*GetTitlePublicKeyResultModel, error) {

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetTitlePublicKey", "", "")
	if err != nil {
		return nil, err
	}

	result := &GetTitlePublicKeyResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetTradeStatus gets the current status of an existing trade.
// https://api.playfab.com/Documentation/Client/method/GetTradeStatus
func GetTradeStatus(settings *playfab.Settings, postData *GetTradeStatusRequestModel, clientSessionTicket string) (*GetTradeStatusResponseModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetTradeStatus", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetTradeStatusResponseModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetUserData retrieves the title-specific custom data for the user which is readable and writable by the client
// https://api.playfab.com/Documentation/Client/method/GetUserData
func GetUserData(settings *playfab.Settings, postData *GetUserDataRequestModel, clientSessionTicket string) (*GetUserDataResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetUserData", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetUserDataResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetUserInventory retrieves the user's current inventory of virtual goods
// https://api.playfab.com/Documentation/Client/method/GetUserInventory
func GetUserInventory(settings *playfab.Settings, postData *GetUserInventoryRequestModel, clientSessionTicket string) (*GetUserInventoryResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetUserInventory", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetUserInventoryResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetUserPublisherData retrieves the publisher-specific custom data for the user which is readable and writable by the client
// https://api.playfab.com/Documentation/Client/method/GetUserPublisherData
func GetUserPublisherData(settings *playfab.Settings, postData *GetUserDataRequestModel, clientSessionTicket string) (*GetUserDataResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetUserPublisherData", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetUserDataResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetUserPublisherReadOnlyData retrieves the publisher-specific custom data for the user which can only be read by the client
// https://api.playfab.com/Documentation/Client/method/GetUserPublisherReadOnlyData
func GetUserPublisherReadOnlyData(settings *playfab.Settings, postData *GetUserDataRequestModel, clientSessionTicket string) (*GetUserDataResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetUserPublisherReadOnlyData", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetUserDataResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetUserReadOnlyData retrieves the title-specific custom data for the user which can only be read by the client
// https://api.playfab.com/Documentation/Client/method/GetUserReadOnlyData
func GetUserReadOnlyData(settings *playfab.Settings, postData *GetUserDataRequestModel, clientSessionTicket string) (*GetUserDataResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetUserReadOnlyData", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GetUserDataResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GetWindowsHelloChallenge requests a challenge from the server to be signed by Windows Hello Passport service to authenticate.
// https://api.playfab.com/Documentation/Client/method/GetWindowsHelloChallenge
func GetWindowsHelloChallenge(settings *playfab.Settings, postData *GetWindowsHelloChallengeRequestModel) (*GetWindowsHelloChallengeResponseModel, error) {

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GetWindowsHelloChallenge", "", "")
	if err != nil {
		return nil, err
	}

	result := &GetWindowsHelloChallengeResponseModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// GrantCharacterToUser grants the specified character type to the user. CharacterIds are not globally unique; characterId must be evaluated
// with the parent PlayFabId to guarantee uniqueness.
// https://api.playfab.com/Documentation/Client/method/GrantCharacterToUser
func GrantCharacterToUser(settings *playfab.Settings, postData *GrantCharacterToUserRequestModel, clientSessionTicket string) (*GrantCharacterToUserResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/GrantCharacterToUser", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &GrantCharacterToUserResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LinkAndroidDeviceID links the Android device identifier to the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/LinkAndroidDeviceID
func LinkAndroidDeviceID(settings *playfab.Settings, postData *LinkAndroidDeviceIDRequestModel, clientSessionTicket string) (*LinkAndroidDeviceIDResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LinkAndroidDeviceID", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &LinkAndroidDeviceIDResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LinkApple links the Apple account associated with the token to the user's PlayFab account.
// https://api.playfab.com/Documentation/Client/method/LinkApple
func LinkApple(settings *playfab.Settings, postData *LinkAppleRequestModel, clientSessionTicket string) (*EmptyResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LinkApple", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &EmptyResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LinkCustomID links the custom identifier, generated by the title, to the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/LinkCustomID
func LinkCustomID(settings *playfab.Settings, postData *LinkCustomIDRequestModel, clientSessionTicket string) (*LinkCustomIDResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LinkCustomID", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &LinkCustomIDResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LinkFacebookAccount links the Facebook account associated with the provided Facebook access token to the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/LinkFacebookAccount
func LinkFacebookAccount(settings *playfab.Settings, postData *LinkFacebookAccountRequestModel, clientSessionTicket string) (*LinkFacebookAccountResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LinkFacebookAccount", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &LinkFacebookAccountResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LinkFacebookInstantGamesId links the Facebook Instant Games Id to the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/LinkFacebookInstantGamesId
func LinkFacebookInstantGamesId(settings *playfab.Settings, postData *LinkFacebookInstantGamesIdRequestModel, clientSessionTicket string) (*LinkFacebookInstantGamesIdResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LinkFacebookInstantGamesId", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &LinkFacebookInstantGamesIdResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LinkGameCenterAccount links the Game Center account associated with the provided Game Center ID to the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/LinkGameCenterAccount
func LinkGameCenterAccount(settings *playfab.Settings, postData *LinkGameCenterAccountRequestModel, clientSessionTicket string) (*LinkGameCenterAccountResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LinkGameCenterAccount", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &LinkGameCenterAccountResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LinkGoogleAccount links the currently signed-in user account to their Google account, using their Google account credentials
// https://api.playfab.com/Documentation/Client/method/LinkGoogleAccount
func LinkGoogleAccount(settings *playfab.Settings, postData *LinkGoogleAccountRequestModel, clientSessionTicket string) (*LinkGoogleAccountResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LinkGoogleAccount", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &LinkGoogleAccountResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LinkIOSDeviceID links the vendor-specific iOS device identifier to the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/LinkIOSDeviceID
func LinkIOSDeviceID(settings *playfab.Settings, postData *LinkIOSDeviceIDRequestModel, clientSessionTicket string) (*LinkIOSDeviceIDResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LinkIOSDeviceID", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &LinkIOSDeviceIDResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LinkKongregate links the Kongregate identifier to the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/LinkKongregate
func LinkKongregate(settings *playfab.Settings, postData *LinkKongregateAccountRequestModel, clientSessionTicket string) (*LinkKongregateAccountResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LinkKongregate", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &LinkKongregateAccountResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LinkNintendoSwitchDeviceId links the NintendoSwitchDeviceId to the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/LinkNintendoSwitchDeviceId
func LinkNintendoSwitchDeviceId(settings *playfab.Settings, postData *LinkNintendoSwitchDeviceIdRequestModel, clientSessionTicket string) (*LinkNintendoSwitchDeviceIdResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LinkNintendoSwitchDeviceId", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &LinkNintendoSwitchDeviceIdResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LinkOpenIdConnect links an OpenID Connect account to a user's PlayFab account, based on an existing relationship between a title and an
// Open ID Connect provider and the OpenId Connect JWT from that provider.
// https://api.playfab.com/Documentation/Client/method/LinkOpenIdConnect
func LinkOpenIdConnect(settings *playfab.Settings, postData *LinkOpenIdConnectRequestModel, clientSessionTicket string) (*EmptyResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LinkOpenIdConnect", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &EmptyResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LinkPSNAccount links the PlayStation Network account associated with the provided access code to the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/LinkPSNAccount
func LinkPSNAccount(settings *playfab.Settings, postData *LinkPSNAccountRequestModel, clientSessionTicket string) (*LinkPSNAccountResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LinkPSNAccount", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &LinkPSNAccountResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LinkSteamAccount links the Steam account associated with the provided Steam authentication ticket to the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/LinkSteamAccount
func LinkSteamAccount(settings *playfab.Settings, postData *LinkSteamAccountRequestModel, clientSessionTicket string) (*LinkSteamAccountResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LinkSteamAccount", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &LinkSteamAccountResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LinkTwitch links the Twitch account associated with the token to the user's PlayFab account.
// https://api.playfab.com/Documentation/Client/method/LinkTwitch
func LinkTwitch(settings *playfab.Settings, postData *LinkTwitchAccountRequestModel, clientSessionTicket string) (*LinkTwitchAccountResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LinkTwitch", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &LinkTwitchAccountResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LinkWindowsHello link Windows Hello authentication to the current PlayFab Account
// https://api.playfab.com/Documentation/Client/method/LinkWindowsHello
func LinkWindowsHello(settings *playfab.Settings, postData *LinkWindowsHelloAccountRequestModel, clientSessionTicket string) (*LinkWindowsHelloAccountResponseModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LinkWindowsHello", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &LinkWindowsHelloAccountResponseModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LinkXboxAccount links the Xbox Live account associated with the provided access code to the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/LinkXboxAccount
func LinkXboxAccount(settings *playfab.Settings, postData *LinkXboxAccountRequestModel, clientSessionTicket string) (*LinkXboxAccountResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LinkXboxAccount", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &LinkXboxAccountResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LoginWithAndroidDeviceID signs the user in using the Android device identifier, returning a session identifier that can subsequently be used for
// API calls which require an authenticated user
// https://api.playfab.com/Documentation/Client/method/LoginWithAndroidDeviceID
func LoginWithAndroidDeviceID(settings *playfab.Settings, postData *LoginWithAndroidDeviceIDRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LoginWithAndroidDeviceID", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LoginWithApple signs in the user with a Sign in with Apple identity token.
// https://api.playfab.com/Documentation/Client/method/LoginWithApple
func LoginWithApple(settings *playfab.Settings, postData *LoginWithAppleRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LoginWithApple", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LoginWithCustomID signs the user in using a custom unique identifier generated by the title, returning a session identifier that can
// subsequently be used for API calls which require an authenticated user
// https://api.playfab.com/Documentation/Client/method/LoginWithCustomID
func LoginWithCustomID(settings *playfab.Settings, postData *LoginWithCustomIDRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LoginWithCustomID", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LoginWithEmailAddress signs the user into the PlayFab account, returning a session identifier that can subsequently be used for API calls
// which require an authenticated user. Unlike most other login API calls, LoginWithEmailAddress does not permit the
// creation of new accounts via the CreateAccountFlag. Email addresses may be used to create accounts via
// RegisterPlayFabUser.
// https://api.playfab.com/Documentation/Client/method/LoginWithEmailAddress
func LoginWithEmailAddress(settings *playfab.Settings, postData *LoginWithEmailAddressRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LoginWithEmailAddress", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LoginWithFacebook signs the user in using a Facebook access token, returning a session identifier that can subsequently be used for API
// calls which require an authenticated user
// https://api.playfab.com/Documentation/Client/method/LoginWithFacebook
func LoginWithFacebook(settings *playfab.Settings, postData *LoginWithFacebookRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LoginWithFacebook", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LoginWithFacebookInstantGamesId signs the user in using a Facebook Instant Games ID, returning a session identifier that can subsequently be used for
// API calls which require an authenticated user. Requires Facebook Instant Games to be configured.
// https://api.playfab.com/Documentation/Client/method/LoginWithFacebookInstantGamesId
func LoginWithFacebookInstantGamesId(settings *playfab.Settings, postData *LoginWithFacebookInstantGamesIdRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LoginWithFacebookInstantGamesId", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LoginWithGameCenter signs the user in using an iOS Game Center player identifier, returning a session identifier that can subsequently be
// used for API calls which require an authenticated user
// https://api.playfab.com/Documentation/Client/method/LoginWithGameCenter
func LoginWithGameCenter(settings *playfab.Settings, postData *LoginWithGameCenterRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LoginWithGameCenter", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LoginWithGoogleAccount signs the user in using their Google account credentials
// https://api.playfab.com/Documentation/Client/method/LoginWithGoogleAccount
func LoginWithGoogleAccount(settings *playfab.Settings, postData *LoginWithGoogleAccountRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LoginWithGoogleAccount", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LoginWithIOSDeviceID signs the user in using the vendor-specific iOS device identifier, returning a session identifier that can subsequently
// be used for API calls which require an authenticated user
// https://api.playfab.com/Documentation/Client/method/LoginWithIOSDeviceID
func LoginWithIOSDeviceID(settings *playfab.Settings, postData *LoginWithIOSDeviceIDRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LoginWithIOSDeviceID", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LoginWithKongregate signs the user in using a Kongregate player account.
// https://api.playfab.com/Documentation/Client/method/LoginWithKongregate
func LoginWithKongregate(settings *playfab.Settings, postData *LoginWithKongregateRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LoginWithKongregate", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LoginWithNintendoSwitchDeviceId signs the user in using a Nintendo Switch Device ID, returning a session identifier that can subsequently be used for
// API calls which require an authenticated user
// https://api.playfab.com/Documentation/Client/method/LoginWithNintendoSwitchDeviceId
func LoginWithNintendoSwitchDeviceId(settings *playfab.Settings, postData *LoginWithNintendoSwitchDeviceIdRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LoginWithNintendoSwitchDeviceId", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LoginWithOpenIdConnect logs in a user with an Open ID Connect JWT created by an existing relationship between a title and an Open ID Connect
// provider.
// https://api.playfab.com/Documentation/Client/method/LoginWithOpenIdConnect
func LoginWithOpenIdConnect(settings *playfab.Settings, postData *LoginWithOpenIdConnectRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LoginWithOpenIdConnect", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LoginWithPlayFab signs the user into the PlayFab account, returning a session identifier that can subsequently be used for API calls
// which require an authenticated user. Unlike most other login API calls, LoginWithPlayFab does not permit the creation of
// new accounts via the CreateAccountFlag. Username/Password credentials may be used to create accounts via
// RegisterPlayFabUser, or added to existing accounts using AddUsernamePassword.
// https://api.playfab.com/Documentation/Client/method/LoginWithPlayFab
func LoginWithPlayFab(settings *playfab.Settings, postData *LoginWithPlayFabRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LoginWithPlayFab", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LoginWithPSN signs the user in using a PlayStation Network authentication code, returning a session identifier that can subsequently
// be used for API calls which require an authenticated user
// https://api.playfab.com/Documentation/Client/method/LoginWithPSN
func LoginWithPSN(settings *playfab.Settings, postData *LoginWithPSNRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LoginWithPSN", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LoginWithSteam signs the user in using a Steam authentication ticket, returning a session identifier that can subsequently be used for
// API calls which require an authenticated user
// https://api.playfab.com/Documentation/Client/method/LoginWithSteam
func LoginWithSteam(settings *playfab.Settings, postData *LoginWithSteamRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LoginWithSteam", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LoginWithTwitch signs the user in using a Twitch access token.
// https://api.playfab.com/Documentation/Client/method/LoginWithTwitch
func LoginWithTwitch(settings *playfab.Settings, postData *LoginWithTwitchRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LoginWithTwitch", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LoginWithWindowsHello completes the Windows Hello login flow by returning the signed value of the challange from GetWindowsHelloChallenge.
// Windows Hello has a 2 step client to server authentication scheme. Step one is to request from the server a challenge
// string. Step two is to request the user sign the string via Windows Hello and then send the signed value back to the
// server.
// https://api.playfab.com/Documentation/Client/method/LoginWithWindowsHello
func LoginWithWindowsHello(settings *playfab.Settings, postData *LoginWithWindowsHelloRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LoginWithWindowsHello", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// LoginWithXbox signs the user in using a Xbox Live Token, returning a session identifier that can subsequently be used for API calls
// which require an authenticated user
// https://api.playfab.com/Documentation/Client/method/LoginWithXbox
func LoginWithXbox(settings *playfab.Settings, postData *LoginWithXboxRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/LoginWithXbox", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// Matchmake attempts to locate a game session matching the given parameters. If the goal is to match the player into a specific
// active session, only the LobbyId is required. Otherwise, the BuildVersion, GameMode, and Region are all required
// parameters. Note that parameters specified in the search are required (they are not weighting factors). If a slot is
// found in a server instance matching the parameters, the slot will be assigned to that player, removing it from the
// availabe set. In that case, the information on the game session will be returned, otherwise the Status returned will be
// GameNotFound.
// https://api.playfab.com/Documentation/Client/method/Matchmake
func Matchmake(settings *playfab.Settings, postData *MatchmakeRequestModel, clientSessionTicket string) (*MatchmakeResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/Matchmake", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &MatchmakeResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// OpenTrade opens a new outstanding trade. Note that a given item instance may only be in one open trade at a time.
// https://api.playfab.com/Documentation/Client/method/OpenTrade
func OpenTrade(settings *playfab.Settings, postData *OpenTradeRequestModel, clientSessionTicket string) (*OpenTradeResponseModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/OpenTrade", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &OpenTradeResponseModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// PayForPurchase selects a payment option for purchase order created via StartPurchase
// https://api.playfab.com/Documentation/Client/method/PayForPurchase
func PayForPurchase(settings *playfab.Settings, postData *PayForPurchaseRequestModel, clientSessionTicket string) (*PayForPurchaseResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/PayForPurchase", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &PayForPurchaseResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// PurchaseItem buys a single item with virtual currency. You must specify both the virtual currency to use to purchase, as well as what
// the client believes the price to be. This lets the server fail the purchase if the price has changed.
// https://api.playfab.com/Documentation/Client/method/PurchaseItem
func PurchaseItem(settings *playfab.Settings, postData *PurchaseItemRequestModel, clientSessionTicket string) (*PurchaseItemResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/PurchaseItem", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &PurchaseItemResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// RedeemCoupon adds the virtual goods associated with the coupon to the user's inventory. Coupons can be generated via the
// Economy->Catalogs tab in the PlayFab Game Manager.
// https://api.playfab.com/Documentation/Client/method/RedeemCoupon
func RedeemCoupon(settings *playfab.Settings, postData *RedeemCouponRequestModel, clientSessionTicket string) (*RedeemCouponResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/RedeemCoupon", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &RedeemCouponResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// RefreshPSNAuthToken uses the supplied OAuth code to refresh the internally cached player PSN auth token
// https://api.playfab.com/Documentation/Client/method/RefreshPSNAuthToken
func RefreshPSNAuthToken(settings *playfab.Settings, postData *RefreshPSNAuthTokenRequestModel, clientSessionTicket string) (*EmptyResponseModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/RefreshPSNAuthToken", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &EmptyResponseModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// RegisterForIOSPushNotification registers the iOS device to receive push notifications
// https://api.playfab.com/Documentation/Client/method/RegisterForIOSPushNotification
func RegisterForIOSPushNotification(settings *playfab.Settings, postData *RegisterForIOSPushNotificationRequestModel, clientSessionTicket string) (*RegisterForIOSPushNotificationResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/RegisterForIOSPushNotification", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &RegisterForIOSPushNotificationResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// RegisterPlayFabUser registers a new Playfab user account, returning a session identifier that can subsequently be used for API calls which
// require an authenticated user. You must supply either a username or an email address.
// https://api.playfab.com/Documentation/Client/method/RegisterPlayFabUser
func RegisterPlayFabUser(settings *playfab.Settings, postData *RegisterPlayFabUserRequestModel) (*RegisterPlayFabUserResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/RegisterPlayFabUser", "", "")
	if err != nil {
		return nil, err
	}

	result := &RegisterPlayFabUserResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// RegisterWithWindowsHello registers a new PlayFab user account using Windows Hello authentication, returning a session ticket that can
// subsequently be used for API calls which require an authenticated user
// https://api.playfab.com/Documentation/Client/method/RegisterWithWindowsHello
func RegisterWithWindowsHello(settings *playfab.Settings, postData *RegisterWithWindowsHelloRequestModel) (*LoginResultModel, error) {
	if postData != nil && postData.TitleId == "" {
		postData.TitleId = settings.TitleId
	}

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/RegisterWithWindowsHello", "", "")
	if err != nil {
		return nil, err
	}

	result := &LoginResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// RemoveContactEmail removes a contact email from the player's profile.
// https://api.playfab.com/Documentation/Client/method/RemoveContactEmail
func RemoveContactEmail(settings *playfab.Settings, postData *RemoveContactEmailRequestModel, clientSessionTicket string) (*RemoveContactEmailResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/RemoveContactEmail", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &RemoveContactEmailResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// RemoveFriend removes a specified user from the friend list of the local user
// https://api.playfab.com/Documentation/Client/method/RemoveFriend
func RemoveFriend(settings *playfab.Settings, postData *RemoveFriendRequestModel, clientSessionTicket string) (*RemoveFriendResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/RemoveFriend", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &RemoveFriendResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// RemoveGenericID removes the specified generic service identifier from the player's PlayFab account.
// https://api.playfab.com/Documentation/Client/method/RemoveGenericID
func RemoveGenericID(settings *playfab.Settings, postData *RemoveGenericIDRequestModel, clientSessionTicket string) (*RemoveGenericIDResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/RemoveGenericID", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &RemoveGenericIDResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// RemoveSharedGroupMembers removes users from the set of those able to update the shared data and the set of users in the group. Only users in the
// group can remove members. If as a result of the call, zero users remain with access, the group and its associated data
// will be deleted. Shared Groups are designed for sharing data between a very small number of players, please see our
// guide: https://docs.microsoft.com/gaming/playfab/features/social/groups/using-shared-group-data
// https://api.playfab.com/Documentation/Client/method/RemoveSharedGroupMembers
func RemoveSharedGroupMembers(settings *playfab.Settings, postData *RemoveSharedGroupMembersRequestModel, clientSessionTicket string) (*RemoveSharedGroupMembersResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/RemoveSharedGroupMembers", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &RemoveSharedGroupMembersResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// ReportDeviceInfo write a PlayStream event to describe the provided player device information. This API method is not designed to be
// called directly by developers. Each PlayFab client SDK will eventually report this information automatically.
// https://api.playfab.com/Documentation/Client/method/ReportDeviceInfo
func ReportDeviceInfo(settings *playfab.Settings, postData *DeviceInfoRequestModel, clientSessionTicket string) (*EmptyResponseModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/ReportDeviceInfo", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &EmptyResponseModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// ReportPlayer submit a report for another player (due to bad bahavior, etc.), so that customer service representatives for the title
// can take action concerning potentially toxic players.
// https://api.playfab.com/Documentation/Client/method/ReportPlayer
func ReportPlayer(settings *playfab.Settings, postData *ReportPlayerClientRequestModel, clientSessionTicket string) (*ReportPlayerClientResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/ReportPlayer", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &ReportPlayerClientResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// RestoreIOSPurchases restores all in-app purchases based on the given restore receipt
// https://api.playfab.com/Documentation/Client/method/RestoreIOSPurchases
func RestoreIOSPurchases(settings *playfab.Settings, postData *RestoreIOSPurchasesRequestModel, clientSessionTicket string) (*RestoreIOSPurchasesResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/RestoreIOSPurchases", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &RestoreIOSPurchasesResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// SendAccountRecoveryEmail forces an email to be sent to the registered email address for the user's account, with a link allowing the user to
// change the password.If an account recovery email template ID is provided, an email using the custom email template will
// be used.
// https://api.playfab.com/Documentation/Client/method/SendAccountRecoveryEmail
func SendAccountRecoveryEmail(settings *playfab.Settings, postData *SendAccountRecoveryEmailRequestModel) (*SendAccountRecoveryEmailResultModel, error) {

	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/SendAccountRecoveryEmail", "", "")
	if err != nil {
		return nil, err
	}

	result := &SendAccountRecoveryEmailResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// SetFriendTags updates the tag list for a specified user in the friend list of the local user
// https://api.playfab.com/Documentation/Client/method/SetFriendTags
func SetFriendTags(settings *playfab.Settings, postData *SetFriendTagsRequestModel, clientSessionTicket string) (*SetFriendTagsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/SetFriendTags", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &SetFriendTagsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// SetPlayerSecret sets the player's secret if it is not already set. Player secrets are used to sign API requests. To reset a player's
// secret use the Admin or Server API method SetPlayerSecret.
// https://api.playfab.com/Documentation/Client/method/SetPlayerSecret
func SetPlayerSecret(settings *playfab.Settings, postData *SetPlayerSecretRequestModel, clientSessionTicket string) (*SetPlayerSecretResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/SetPlayerSecret", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &SetPlayerSecretResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// StartGame start a new game server with a given configuration, add the current player and return the connection information.
// https://api.playfab.com/Documentation/Client/method/StartGame
func StartGame(settings *playfab.Settings, postData *StartGameRequestModel, clientSessionTicket string) (*StartGameResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/StartGame", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &StartGameResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// StartPurchase creates an order for a list of items from the title catalog
// https://api.playfab.com/Documentation/Client/method/StartPurchase
func StartPurchase(settings *playfab.Settings, postData *StartPurchaseRequestModel, clientSessionTicket string) (*StartPurchaseResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/StartPurchase", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &StartPurchaseResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// SubtractUserVirtualCurrency decrements the user's balance of the specified virtual currency by the stated amount. It is possible to make a VC
// balance negative with this API.
// https://api.playfab.com/Documentation/Client/method/SubtractUserVirtualCurrency
func SubtractUserVirtualCurrency(settings *playfab.Settings, postData *SubtractUserVirtualCurrencyRequestModel, clientSessionTicket string) (*ModifyUserVirtualCurrencyResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/SubtractUserVirtualCurrency", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &ModifyUserVirtualCurrencyResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UnlinkAndroidDeviceID unlinks the related Android device identifier from the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/UnlinkAndroidDeviceID
func UnlinkAndroidDeviceID(settings *playfab.Settings, postData *UnlinkAndroidDeviceIDRequestModel, clientSessionTicket string) (*UnlinkAndroidDeviceIDResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UnlinkAndroidDeviceID", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UnlinkAndroidDeviceIDResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UnlinkApple unlinks the related Apple account from the user's PlayFab account.
// https://api.playfab.com/Documentation/Client/method/UnlinkApple
func UnlinkApple(settings *playfab.Settings, postData *UnlinkAppleRequestModel, clientSessionTicket string) (*EmptyResponseModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UnlinkApple", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &EmptyResponseModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UnlinkCustomID unlinks the related custom identifier from the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/UnlinkCustomID
func UnlinkCustomID(settings *playfab.Settings, postData *UnlinkCustomIDRequestModel, clientSessionTicket string) (*UnlinkCustomIDResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UnlinkCustomID", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UnlinkCustomIDResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UnlinkFacebookAccount unlinks the related Facebook account from the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/UnlinkFacebookAccount
func UnlinkFacebookAccount(settings *playfab.Settings, postData *UnlinkFacebookAccountRequestModel, clientSessionTicket string) (*UnlinkFacebookAccountResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UnlinkFacebookAccount", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UnlinkFacebookAccountResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UnlinkFacebookInstantGamesId unlinks the related Facebook Instant Game Ids from the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/UnlinkFacebookInstantGamesId
func UnlinkFacebookInstantGamesId(settings *playfab.Settings, postData *UnlinkFacebookInstantGamesIdRequestModel, clientSessionTicket string) (*UnlinkFacebookInstantGamesIdResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UnlinkFacebookInstantGamesId", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UnlinkFacebookInstantGamesIdResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UnlinkGameCenterAccount unlinks the related Game Center account from the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/UnlinkGameCenterAccount
func UnlinkGameCenterAccount(settings *playfab.Settings, postData *UnlinkGameCenterAccountRequestModel, clientSessionTicket string) (*UnlinkGameCenterAccountResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UnlinkGameCenterAccount", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UnlinkGameCenterAccountResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UnlinkGoogleAccount unlinks the related Google account from the user's PlayFab account
// (https://developers.google.com/android/reference/com/google/android/gms/auth/GoogleAuthUtil#public-methods).
// https://api.playfab.com/Documentation/Client/method/UnlinkGoogleAccount
func UnlinkGoogleAccount(settings *playfab.Settings, postData *UnlinkGoogleAccountRequestModel, clientSessionTicket string) (*UnlinkGoogleAccountResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UnlinkGoogleAccount", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UnlinkGoogleAccountResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UnlinkIOSDeviceID unlinks the related iOS device identifier from the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/UnlinkIOSDeviceID
func UnlinkIOSDeviceID(settings *playfab.Settings, postData *UnlinkIOSDeviceIDRequestModel, clientSessionTicket string) (*UnlinkIOSDeviceIDResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UnlinkIOSDeviceID", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UnlinkIOSDeviceIDResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UnlinkKongregate unlinks the related Kongregate identifier from the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/UnlinkKongregate
func UnlinkKongregate(settings *playfab.Settings, postData *UnlinkKongregateAccountRequestModel, clientSessionTicket string) (*UnlinkKongregateAccountResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UnlinkKongregate", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UnlinkKongregateAccountResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UnlinkNintendoSwitchDeviceId unlinks the related NintendoSwitchDeviceId from the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/UnlinkNintendoSwitchDeviceId
func UnlinkNintendoSwitchDeviceId(settings *playfab.Settings, postData *UnlinkNintendoSwitchDeviceIdRequestModel, clientSessionTicket string) (*UnlinkNintendoSwitchDeviceIdResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UnlinkNintendoSwitchDeviceId", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UnlinkNintendoSwitchDeviceIdResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UnlinkOpenIdConnect unlinks an OpenID Connect account from a user's PlayFab account, based on the connection ID of an existing relationship
// between a title and an Open ID Connect provider.
// https://api.playfab.com/Documentation/Client/method/UnlinkOpenIdConnect
func UnlinkOpenIdConnect(settings *playfab.Settings, postData *UninkOpenIdConnectRequestModel, clientSessionTicket string) (*EmptyResponseModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UnlinkOpenIdConnect", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &EmptyResponseModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UnlinkPSNAccount unlinks the related PSN account from the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/UnlinkPSNAccount
func UnlinkPSNAccount(settings *playfab.Settings, postData *UnlinkPSNAccountRequestModel, clientSessionTicket string) (*UnlinkPSNAccountResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UnlinkPSNAccount", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UnlinkPSNAccountResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UnlinkSteamAccount unlinks the related Steam account from the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/UnlinkSteamAccount
func UnlinkSteamAccount(settings *playfab.Settings, postData *UnlinkSteamAccountRequestModel, clientSessionTicket string) (*UnlinkSteamAccountResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UnlinkSteamAccount", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UnlinkSteamAccountResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UnlinkTwitch unlinks the related Twitch account from the user's PlayFab account.
// https://api.playfab.com/Documentation/Client/method/UnlinkTwitch
func UnlinkTwitch(settings *playfab.Settings, postData *UnlinkTwitchAccountRequestModel, clientSessionTicket string) (*UnlinkTwitchAccountResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UnlinkTwitch", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UnlinkTwitchAccountResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UnlinkWindowsHello unlink Windows Hello authentication from the current PlayFab Account
// https://api.playfab.com/Documentation/Client/method/UnlinkWindowsHello
func UnlinkWindowsHello(settings *playfab.Settings, postData *UnlinkWindowsHelloAccountRequestModel, clientSessionTicket string) (*UnlinkWindowsHelloAccountResponseModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UnlinkWindowsHello", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UnlinkWindowsHelloAccountResponseModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UnlinkXboxAccount unlinks the related Xbox Live account from the user's PlayFab account
// https://api.playfab.com/Documentation/Client/method/UnlinkXboxAccount
func UnlinkXboxAccount(settings *playfab.Settings, postData *UnlinkXboxAccountRequestModel, clientSessionTicket string) (*UnlinkXboxAccountResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UnlinkXboxAccount", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UnlinkXboxAccountResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UnlockContainerInstance opens the specified container, with the specified key (when required), and returns the contents of the opened container.
// If the container (and key when relevant) are consumable (RemainingUses > 0), their RemainingUses will be decremented,
// consistent with the operation of ConsumeItem.
// https://api.playfab.com/Documentation/Client/method/UnlockContainerInstance
func UnlockContainerInstance(settings *playfab.Settings, postData *UnlockContainerInstanceRequestModel, clientSessionTicket string) (*UnlockContainerItemResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UnlockContainerInstance", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UnlockContainerItemResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UnlockContainerItem searches target inventory for an ItemInstance matching the given CatalogItemId, if necessary unlocks it using an
// appropriate key, and returns the contents of the opened container. If the container (and key when relevant) are
// consumable (RemainingUses > 0), their RemainingUses will be decremented, consistent with the operation of ConsumeItem.
// https://api.playfab.com/Documentation/Client/method/UnlockContainerItem
func UnlockContainerItem(settings *playfab.Settings, postData *UnlockContainerItemRequestModel, clientSessionTicket string) (*UnlockContainerItemResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UnlockContainerItem", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UnlockContainerItemResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UpdateAvatarUrl update the avatar URL of the player
// https://api.playfab.com/Documentation/Client/method/UpdateAvatarUrl
func UpdateAvatarUrl(settings *playfab.Settings, postData *UpdateAvatarUrlRequestModel, clientSessionTicket string) (*EmptyResponseModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UpdateAvatarUrl", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &EmptyResponseModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UpdateCharacterData creates and updates the title-specific custom data for the user's character which is readable and writable by the client
// https://api.playfab.com/Documentation/Client/method/UpdateCharacterData
func UpdateCharacterData(settings *playfab.Settings, postData *UpdateCharacterDataRequestModel, clientSessionTicket string) (*UpdateCharacterDataResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UpdateCharacterData", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UpdateCharacterDataResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UpdateCharacterStatistics updates the values of the specified title-specific statistics for the specific character. By default, clients are not
// permitted to update statistics. Developers may override this setting in the Game Manager > Settings > API Features.
// https://api.playfab.com/Documentation/Client/method/UpdateCharacterStatistics
func UpdateCharacterStatistics(settings *playfab.Settings, postData *UpdateCharacterStatisticsRequestModel, clientSessionTicket string) (*UpdateCharacterStatisticsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UpdateCharacterStatistics", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UpdateCharacterStatisticsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UpdatePlayerStatistics updates the values of the specified title-specific statistics for the user. By default, clients are not permitted to
// update statistics. Developers may override this setting in the Game Manager > Settings > API Features.
// https://api.playfab.com/Documentation/Client/method/UpdatePlayerStatistics
func UpdatePlayerStatistics(settings *playfab.Settings, postData *UpdatePlayerStatisticsRequestModel, clientSessionTicket string) (*UpdatePlayerStatisticsResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UpdatePlayerStatistics", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UpdatePlayerStatisticsResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UpdateSharedGroupData adds, updates, and removes data keys for a shared group object. If the permission is set to Public, all fields updated
// or added in this call will be readable by users not in the group. By default, data permissions are set to Private.
// Regardless of the permission setting, only members of the group can update the data. Shared Groups are designed for
// sharing data between a very small number of players, please see our guide:
// https://docs.microsoft.com/gaming/playfab/features/social/groups/using-shared-group-data
// https://api.playfab.com/Documentation/Client/method/UpdateSharedGroupData
func UpdateSharedGroupData(settings *playfab.Settings, postData *UpdateSharedGroupDataRequestModel, clientSessionTicket string) (*UpdateSharedGroupDataResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UpdateSharedGroupData", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UpdateSharedGroupDataResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UpdateUserData creates and updates the title-specific custom data for the user which is readable and writable by the client
// https://api.playfab.com/Documentation/Client/method/UpdateUserData
func UpdateUserData(settings *playfab.Settings, postData *UpdateUserDataRequestModel, clientSessionTicket string) (*UpdateUserDataResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UpdateUserData", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UpdateUserDataResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UpdateUserPublisherData creates and updates the publisher-specific custom data for the user which is readable and writable by the client
// https://api.playfab.com/Documentation/Client/method/UpdateUserPublisherData
func UpdateUserPublisherData(settings *playfab.Settings, postData *UpdateUserDataRequestModel, clientSessionTicket string) (*UpdateUserDataResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UpdateUserPublisherData", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UpdateUserDataResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// UpdateUserTitleDisplayName updates the title specific display name for the user
// https://api.playfab.com/Documentation/Client/method/UpdateUserTitleDisplayName
func UpdateUserTitleDisplayName(settings *playfab.Settings, postData *UpdateUserTitleDisplayNameRequestModel, clientSessionTicket string) (*UpdateUserTitleDisplayNameResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/UpdateUserTitleDisplayName", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &UpdateUserTitleDisplayNameResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// ValidateAmazonIAPReceipt validates with Amazon that the receipt for an Amazon App Store in-app purchase is valid and that it matches the
// purchased catalog item
// https://api.playfab.com/Documentation/Client/method/ValidateAmazonIAPReceipt
func ValidateAmazonIAPReceipt(settings *playfab.Settings, postData *ValidateAmazonReceiptRequestModel, clientSessionTicket string) (*ValidateAmazonReceiptResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/ValidateAmazonIAPReceipt", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &ValidateAmazonReceiptResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// ValidateGooglePlayPurchase validates a Google Play purchase and gives the corresponding item to the player.
// https://api.playfab.com/Documentation/Client/method/ValidateGooglePlayPurchase
func ValidateGooglePlayPurchase(settings *playfab.Settings, postData *ValidateGooglePlayPurchaseRequestModel, clientSessionTicket string) (*ValidateGooglePlayPurchaseResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/ValidateGooglePlayPurchase", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &ValidateGooglePlayPurchaseResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// ValidateIOSReceipt validates with the Apple store that the receipt for an iOS in-app purchase is valid and that it matches the purchased
// catalog item
// https://api.playfab.com/Documentation/Client/method/ValidateIOSReceipt
func ValidateIOSReceipt(settings *playfab.Settings, postData *ValidateIOSReceiptRequestModel, clientSessionTicket string) (*ValidateIOSReceiptResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/ValidateIOSReceipt", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &ValidateIOSReceiptResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// ValidateWindowsStoreReceipt validates with Windows that the receipt for an Windows App Store in-app purchase is valid and that it matches the
// purchased catalog item
// https://api.playfab.com/Documentation/Client/method/ValidateWindowsStoreReceipt
func ValidateWindowsStoreReceipt(settings *playfab.Settings, postData *ValidateWindowsReceiptRequestModel, clientSessionTicket string) (*ValidateWindowsReceiptResultModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/ValidateWindowsStoreReceipt", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &ValidateWindowsReceiptResultModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// WriteCharacterEvent writes a character-based event into PlayStream.
// https://api.playfab.com/Documentation/Client/method/WriteCharacterEvent
func WriteCharacterEvent(settings *playfab.Settings, postData *WriteClientCharacterEventRequestModel, clientSessionTicket string) (*WriteEventResponseModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/WriteCharacterEvent", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &WriteEventResponseModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// WritePlayerEvent writes a player-based event into PlayStream.
// https://api.playfab.com/Documentation/Client/method/WritePlayerEvent
func WritePlayerEvent(settings *playfab.Settings, postData *WriteClientPlayerEventRequestModel, clientSessionTicket string) (*WriteEventResponseModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/WritePlayerEvent", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &WriteEventResponseModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}

// WriteTitleEvent writes a title-based event into PlayStream.
// https://api.playfab.com/Documentation/Client/method/WriteTitleEvent
func WriteTitleEvent(settings *playfab.Settings, postData *WriteTitleEventRequestModel, clientSessionTicket string) (*WriteEventResponseModel, error) {
	if clientSessionTicket == "" {
		return nil, playfab.NewCustomError("clientSessionTicket should not be an empty string", playfab.ErrorGeneric)
	}
	b, errMarshal := json.Marshal(postData)
	if errMarshal != nil {
		return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
	}

	sourceMap, err := playfab.Request(settings, b, "/Client/WriteTitleEvent", "X-Authentication", clientSessionTicket)
	if err != nil {
		return nil, err
	}

	result := &WriteEventResponseModel{}

	config := mapstructure.DecoderConfig{
		DecodeHook: playfab.StringToDateTimeHook,
		Result:     result,
	}

	decoder, errDecoding := mapstructure.NewDecoder(&config)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	errDecoding = decoder.Decode(sourceMap)
	if errDecoding != nil {
		return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
	}

	return result, nil
}
