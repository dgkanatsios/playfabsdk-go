package multiplayer

// This code was generated by a tool. Any changes may be overwritten

import (
    "encoding/json"

    playfab "github.com/dgkanatsios/playfabsdk-go/sdk"

    "github.com/mitchellh/mapstructure"
)

// CancelAllMatchmakingTicketsForPlayer cancel all active tickets the player is a member of in a given queue.
// https://api.playfab.com/Documentation/Multiplayer/method/CancelAllMatchmakingTicketsForPlayer
func CancelAllMatchmakingTicketsForPlayer(settings *playfab.Settings, postData *CancelAllMatchmakingTicketsForPlayerRequestModel, entityToken string) (*CancelAllMatchmakingTicketsForPlayerResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Match/CancelAllMatchmakingTicketsForPlayer", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CancelAllMatchmakingTicketsForPlayerResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CancelAllServerBackfillTicketsForPlayer cancel all active backfill tickets the player is a member of in a given queue.
// https://api.playfab.com/Documentation/Multiplayer/method/CancelAllServerBackfillTicketsForPlayer
func CancelAllServerBackfillTicketsForPlayer(settings *playfab.Settings, postData *CancelAllServerBackfillTicketsForPlayerRequestModel, entityToken string) (*CancelAllServerBackfillTicketsForPlayerResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Match/CancelAllServerBackfillTicketsForPlayer", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CancelAllServerBackfillTicketsForPlayerResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CancelMatchmakingTicket cancel a matchmaking ticket.
// https://api.playfab.com/Documentation/Multiplayer/method/CancelMatchmakingTicket
func CancelMatchmakingTicket(settings *playfab.Settings, postData *CancelMatchmakingTicketRequestModel, entityToken string) (*CancelMatchmakingTicketResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Match/CancelMatchmakingTicket", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CancelMatchmakingTicketResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CancelServerBackfillTicket cancel a server backfill ticket.
// https://api.playfab.com/Documentation/Multiplayer/method/CancelServerBackfillTicket
func CancelServerBackfillTicket(settings *playfab.Settings, postData *CancelServerBackfillTicketRequestModel, entityToken string) (*CancelServerBackfillTicketResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Match/CancelServerBackfillTicket", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CancelServerBackfillTicketResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateBuildAlias creates a multiplayer server build alias.
// https://api.playfab.com/Documentation/Multiplayer/method/CreateBuildAlias
func CreateBuildAlias(settings *playfab.Settings, postData *CreateBuildAliasRequestModel, entityToken string) (*BuildAliasDetailsResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/CreateBuildAlias", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &BuildAliasDetailsResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateBuildWithCustomContainer creates a multiplayer server build with a custom container.
// https://api.playfab.com/Documentation/Multiplayer/method/CreateBuildWithCustomContainer
func CreateBuildWithCustomContainer(settings *playfab.Settings, postData *CreateBuildWithCustomContainerRequestModel, entityToken string) (*CreateBuildWithCustomContainerResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/CreateBuildWithCustomContainer", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CreateBuildWithCustomContainerResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateBuildWithManagedContainer creates a multiplayer server build with a managed container.
// https://api.playfab.com/Documentation/Multiplayer/method/CreateBuildWithManagedContainer
func CreateBuildWithManagedContainer(settings *playfab.Settings, postData *CreateBuildWithManagedContainerRequestModel, entityToken string) (*CreateBuildWithManagedContainerResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/CreateBuildWithManagedContainer", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CreateBuildWithManagedContainerResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateBuildWithProcessBasedServer creates a multiplayer server build with the server running as a process.
// https://api.playfab.com/Documentation/Multiplayer/method/CreateBuildWithProcessBasedServer
func CreateBuildWithProcessBasedServer(settings *playfab.Settings, postData *CreateBuildWithProcessBasedServerRequestModel, entityToken string) (*CreateBuildWithProcessBasedServerResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/CreateBuildWithProcessBasedServer", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CreateBuildWithProcessBasedServerResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateLobby create a lobby.
// https://api.playfab.com/Documentation/Multiplayer/method/CreateLobby
func CreateLobby(settings *playfab.Settings, postData *CreateLobbyRequestModel, entityToken string) (*CreateLobbyResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Lobby/CreateLobby", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CreateLobbyResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateMatchmakingTicket create a matchmaking ticket as a client.
// https://api.playfab.com/Documentation/Multiplayer/method/CreateMatchmakingTicket
func CreateMatchmakingTicket(settings *playfab.Settings, postData *CreateMatchmakingTicketRequestModel, entityToken string) (*CreateMatchmakingTicketResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Match/CreateMatchmakingTicket", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CreateMatchmakingTicketResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateRemoteUser creates a remote user to log on to a VM for a multiplayer server build.
// https://api.playfab.com/Documentation/Multiplayer/method/CreateRemoteUser
func CreateRemoteUser(settings *playfab.Settings, postData *CreateRemoteUserRequestModel, entityToken string) (*CreateRemoteUserResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/CreateRemoteUser", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CreateRemoteUserResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateServerBackfillTicket create a backfill matchmaking ticket as a server. A backfill ticket represents an ongoing game. The matchmaking service
// automatically starts matching the backfill ticket against other matchmaking tickets. Backfill tickets cannot match with
// other backfill tickets.
// https://api.playfab.com/Documentation/Multiplayer/method/CreateServerBackfillTicket
func CreateServerBackfillTicket(settings *playfab.Settings, postData *CreateServerBackfillTicketRequestModel, entityToken string) (*CreateServerBackfillTicketResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Match/CreateServerBackfillTicket", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CreateServerBackfillTicketResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateServerMatchmakingTicket create a matchmaking ticket as a server. The matchmaking service automatically starts matching the ticket against other
// matchmaking tickets.
// https://api.playfab.com/Documentation/Multiplayer/method/CreateServerMatchmakingTicket
func CreateServerMatchmakingTicket(settings *playfab.Settings, postData *CreateServerMatchmakingTicketRequestModel, entityToken string) (*CreateMatchmakingTicketResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Match/CreateServerMatchmakingTicket", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CreateMatchmakingTicketResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateTitleMultiplayerServersQuotaChange creates a request to change a title's multiplayer server quotas.
// https://api.playfab.com/Documentation/Multiplayer/method/CreateTitleMultiplayerServersQuotaChange
func CreateTitleMultiplayerServersQuotaChange(settings *playfab.Settings, postData *CreateTitleMultiplayerServersQuotaChangeRequestModel, entityToken string) (*CreateTitleMultiplayerServersQuotaChangeResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/CreateTitleMultiplayerServersQuotaChange", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CreateTitleMultiplayerServersQuotaChangeResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeleteAsset deletes a multiplayer server game asset for a title.
// https://api.playfab.com/Documentation/Multiplayer/method/DeleteAsset
func DeleteAsset(settings *playfab.Settings, postData *DeleteAssetRequestModel, entityToken string) (*EmptyResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/DeleteAsset", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeleteBuild deletes a multiplayer server build.
// https://api.playfab.com/Documentation/Multiplayer/method/DeleteBuild
func DeleteBuild(settings *playfab.Settings, postData *DeleteBuildRequestModel, entityToken string) (*EmptyResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/DeleteBuild", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeleteBuildAlias deletes a multiplayer server build alias.
// https://api.playfab.com/Documentation/Multiplayer/method/DeleteBuildAlias
func DeleteBuildAlias(settings *playfab.Settings, postData *DeleteBuildAliasRequestModel, entityToken string) (*EmptyResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/DeleteBuildAlias", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeleteBuildRegion removes a multiplayer server build's region.
// https://api.playfab.com/Documentation/Multiplayer/method/DeleteBuildRegion
func DeleteBuildRegion(settings *playfab.Settings, postData *DeleteBuildRegionRequestModel, entityToken string) (*EmptyResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/DeleteBuildRegion", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeleteCertificate deletes a multiplayer server game certificate.
// https://api.playfab.com/Documentation/Multiplayer/method/DeleteCertificate
func DeleteCertificate(settings *playfab.Settings, postData *DeleteCertificateRequestModel, entityToken string) (*EmptyResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/DeleteCertificate", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeleteContainerImageRepository deletes a container image repository.
// https://api.playfab.com/Documentation/Multiplayer/method/DeleteContainerImageRepository
func DeleteContainerImageRepository(settings *playfab.Settings, postData *DeleteContainerImageRequestModel, entityToken string) (*EmptyResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/DeleteContainerImageRepository", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeleteLobby delete a lobby.
// https://api.playfab.com/Documentation/Multiplayer/method/DeleteLobby
func DeleteLobby(settings *playfab.Settings, postData *DeleteLobbyRequestModel, entityToken string) (*LobbyEmptyResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Lobby/DeleteLobby", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &LobbyEmptyResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeleteRemoteUser deletes a remote user to log on to a VM for a multiplayer server build.
// https://api.playfab.com/Documentation/Multiplayer/method/DeleteRemoteUser
func DeleteRemoteUser(settings *playfab.Settings, postData *DeleteRemoteUserRequestModel, entityToken string) (*EmptyResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/DeleteRemoteUser", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// EnableMultiplayerServersForTitle enables the multiplayer server feature for a title.
// https://api.playfab.com/Documentation/Multiplayer/method/EnableMultiplayerServersForTitle
func EnableMultiplayerServersForTitle(settings *playfab.Settings, postData *EnableMultiplayerServersForTitleRequestModel, entityToken string) (*EnableMultiplayerServersForTitleResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/EnableMultiplayerServersForTitle", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &EnableMultiplayerServersForTitleResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// FindFriendLobbies find lobbies which match certain criteria, and which friends are in.
// https://api.playfab.com/Documentation/Multiplayer/method/FindFriendLobbies
func FindFriendLobbies(settings *playfab.Settings, postData *FindFriendLobbiesRequestModel, entityToken string) (*FindFriendLobbiesResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Lobby/FindFriendLobbies", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &FindFriendLobbiesResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// FindLobbies find all the lobbies that match certain criteria.
// https://api.playfab.com/Documentation/Multiplayer/method/FindLobbies
func FindLobbies(settings *playfab.Settings, postData *FindLobbiesRequestModel, entityToken string) (*FindLobbiesResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Lobby/FindLobbies", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &FindLobbiesResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetAssetDownloadUrl gets a URL that can be used to download the specified asset. A sample pre-authenticated url -
// https://sampleStorageAccount.blob.core.windows.net/gameassets/gameserver.zip?sv=2015-04-05&ss=b&srt=sco&sp=rw&st=startDate&se=endDate&spr=https&sig=sampleSig&api-version=2017-07-29
// https://api.playfab.com/Documentation/Multiplayer/method/GetAssetDownloadUrl
func GetAssetDownloadUrl(settings *playfab.Settings, postData *GetAssetDownloadUrlRequestModel, entityToken string) (*GetAssetDownloadUrlResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/GetAssetDownloadUrl", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetAssetDownloadUrlResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetAssetUploadUrl gets the URL to upload assets to. A sample pre-authenticated url -
// https://sampleStorageAccount.blob.core.windows.net/gameassets/gameserver.zip?sv=2015-04-05&ss=b&srt=sco&sp=rw&st=startDate&se=endDate&spr=https&sig=sampleSig&api-version=2017-07-29
// https://api.playfab.com/Documentation/Multiplayer/method/GetAssetUploadUrl
func GetAssetUploadUrl(settings *playfab.Settings, postData *GetAssetUploadUrlRequestModel, entityToken string) (*GetAssetUploadUrlResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/GetAssetUploadUrl", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetAssetUploadUrlResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetBuild gets a multiplayer server build.
// https://api.playfab.com/Documentation/Multiplayer/method/GetBuild
func GetBuild(settings *playfab.Settings, postData *GetBuildRequestModel, entityToken string) (*GetBuildResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/GetBuild", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetBuildResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetBuildAlias gets a multiplayer server build alias.
// https://api.playfab.com/Documentation/Multiplayer/method/GetBuildAlias
func GetBuildAlias(settings *playfab.Settings, postData *GetBuildAliasRequestModel, entityToken string) (*BuildAliasDetailsResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/GetBuildAlias", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &BuildAliasDetailsResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetContainerRegistryCredentials gets the credentials to the container registry.
// https://api.playfab.com/Documentation/Multiplayer/method/GetContainerRegistryCredentials
func GetContainerRegistryCredentials(settings *playfab.Settings, postData *GetContainerRegistryCredentialsRequestModel, entityToken string) (*GetContainerRegistryCredentialsResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/GetContainerRegistryCredentials", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetContainerRegistryCredentialsResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetLobby get a lobby.
// https://api.playfab.com/Documentation/Multiplayer/method/GetLobby
func GetLobby(settings *playfab.Settings, postData *GetLobbyRequestModel, entityToken string) (*GetLobbyResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Lobby/GetLobby", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetLobbyResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetMatch get a match.
// https://api.playfab.com/Documentation/Multiplayer/method/GetMatch
func GetMatch(settings *playfab.Settings, postData *GetMatchRequestModel, entityToken string) (*GetMatchResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Match/GetMatch", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetMatchResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetMatchmakingTicket get a matchmaking ticket by ticket Id.
// https://api.playfab.com/Documentation/Multiplayer/method/GetMatchmakingTicket
func GetMatchmakingTicket(settings *playfab.Settings, postData *GetMatchmakingTicketRequestModel, entityToken string) (*GetMatchmakingTicketResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Match/GetMatchmakingTicket", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetMatchmakingTicketResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetMultiplayerServerDetails gets multiplayer server session details for a build.
// https://api.playfab.com/Documentation/Multiplayer/method/GetMultiplayerServerDetails
func GetMultiplayerServerDetails(settings *playfab.Settings, postData *GetMultiplayerServerDetailsRequestModel, entityToken string) (*GetMultiplayerServerDetailsResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/GetMultiplayerServerDetails", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetMultiplayerServerDetailsResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetMultiplayerServerLogs gets multiplayer server logs after a server has terminated.
// https://api.playfab.com/Documentation/Multiplayer/method/GetMultiplayerServerLogs
func GetMultiplayerServerLogs(settings *playfab.Settings, postData *GetMultiplayerServerLogsRequestModel, entityToken string) (*GetMultiplayerServerLogsResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/GetMultiplayerServerLogs", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetMultiplayerServerLogsResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetMultiplayerSessionLogsBySessionId gets multiplayer server logs after a server has terminated.
// https://api.playfab.com/Documentation/Multiplayer/method/GetMultiplayerSessionLogsBySessionId
func GetMultiplayerSessionLogsBySessionId(settings *playfab.Settings, postData *GetMultiplayerSessionLogsBySessionIdRequestModel, entityToken string) (*GetMultiplayerServerLogsResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/GetMultiplayerSessionLogsBySessionId", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetMultiplayerServerLogsResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetQueueStatistics get the statistics for a queue.
// https://api.playfab.com/Documentation/Multiplayer/method/GetQueueStatistics
func GetQueueStatistics(settings *playfab.Settings, postData *GetQueueStatisticsRequestModel, entityToken string) (*GetQueueStatisticsResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Match/GetQueueStatistics", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetQueueStatisticsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetRemoteLoginEndpoint gets a remote login endpoint to a VM that is hosting a multiplayer server build.
// https://api.playfab.com/Documentation/Multiplayer/method/GetRemoteLoginEndpoint
func GetRemoteLoginEndpoint(settings *playfab.Settings, postData *GetRemoteLoginEndpointRequestModel, entityToken string) (*GetRemoteLoginEndpointResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/GetRemoteLoginEndpoint", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetRemoteLoginEndpointResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetServerBackfillTicket get a matchmaking backfill ticket by ticket Id.
// https://api.playfab.com/Documentation/Multiplayer/method/GetServerBackfillTicket
func GetServerBackfillTicket(settings *playfab.Settings, postData *GetServerBackfillTicketRequestModel, entityToken string) (*GetServerBackfillTicketResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Match/GetServerBackfillTicket", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetServerBackfillTicketResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetTitleEnabledForMultiplayerServersStatus gets the status of whether a title is enabled for the multiplayer server feature.
// https://api.playfab.com/Documentation/Multiplayer/method/GetTitleEnabledForMultiplayerServersStatus
func GetTitleEnabledForMultiplayerServersStatus(settings *playfab.Settings, postData *GetTitleEnabledForMultiplayerServersStatusRequestModel, entityToken string) (*GetTitleEnabledForMultiplayerServersStatusResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/GetTitleEnabledForMultiplayerServersStatus", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetTitleEnabledForMultiplayerServersStatusResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetTitleMultiplayerServersQuotaChange gets a title's server quota change request.
// https://api.playfab.com/Documentation/Multiplayer/method/GetTitleMultiplayerServersQuotaChange
func GetTitleMultiplayerServersQuotaChange(settings *playfab.Settings, postData *GetTitleMultiplayerServersQuotaChangeRequestModel, entityToken string) (*GetTitleMultiplayerServersQuotaChangeResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/GetTitleMultiplayerServersQuotaChange", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetTitleMultiplayerServersQuotaChangeResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetTitleMultiplayerServersQuotas gets the quotas for a title in relation to multiplayer servers.
// https://api.playfab.com/Documentation/Multiplayer/method/GetTitleMultiplayerServersQuotas
func GetTitleMultiplayerServersQuotas(settings *playfab.Settings, postData *GetTitleMultiplayerServersQuotasRequestModel, entityToken string) (*GetTitleMultiplayerServersQuotasResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/GetTitleMultiplayerServersQuotas", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetTitleMultiplayerServersQuotasResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// InviteToLobby send a notification to invite a player to a lobby.
// https://api.playfab.com/Documentation/Multiplayer/method/InviteToLobby
func InviteToLobby(settings *playfab.Settings, postData *InviteToLobbyRequestModel, entityToken string) (*LobbyEmptyResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Lobby/InviteToLobby", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &LobbyEmptyResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// JoinArrangedLobby join an Arranged lobby.
// https://api.playfab.com/Documentation/Multiplayer/method/JoinArrangedLobby
func JoinArrangedLobby(settings *playfab.Settings, postData *JoinArrangedLobbyRequestModel, entityToken string) (*JoinLobbyResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Lobby/JoinArrangedLobby", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &JoinLobbyResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// JoinLobby join a lobby.
// https://api.playfab.com/Documentation/Multiplayer/method/JoinLobby
func JoinLobby(settings *playfab.Settings, postData *JoinLobbyRequestModel, entityToken string) (*JoinLobbyResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Lobby/JoinLobby", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &JoinLobbyResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// JoinMatchmakingTicket join a matchmaking ticket.
// https://api.playfab.com/Documentation/Multiplayer/method/JoinMatchmakingTicket
func JoinMatchmakingTicket(settings *playfab.Settings, postData *JoinMatchmakingTicketRequestModel, entityToken string) (*JoinMatchmakingTicketResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Match/JoinMatchmakingTicket", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &JoinMatchmakingTicketResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// LeaveLobby leave a lobby.
// https://api.playfab.com/Documentation/Multiplayer/method/LeaveLobby
func LeaveLobby(settings *playfab.Settings, postData *LeaveLobbyRequestModel, entityToken string) (*LobbyEmptyResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Lobby/LeaveLobby", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &LobbyEmptyResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ListArchivedMultiplayerServers lists archived multiplayer server sessions for a build.
// https://api.playfab.com/Documentation/Multiplayer/method/ListArchivedMultiplayerServers
func ListArchivedMultiplayerServers(settings *playfab.Settings, postData *ListMultiplayerServersRequestModel, entityToken string) (*ListMultiplayerServersResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/ListArchivedMultiplayerServers", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &ListMultiplayerServersResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ListAssetSummaries lists multiplayer server game assets for a title.
// https://api.playfab.com/Documentation/Multiplayer/method/ListAssetSummaries
func ListAssetSummaries(settings *playfab.Settings, postData *ListAssetSummariesRequestModel, entityToken string) (*ListAssetSummariesResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/ListAssetSummaries", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &ListAssetSummariesResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ListBuildAliases lists details of all build aliases for a title. Accepts tokens for title and if game client access is enabled, allows
// game client to request list of builds with player entity token.
// https://api.playfab.com/Documentation/Multiplayer/method/ListBuildAliases
func ListBuildAliases(settings *playfab.Settings, postData *ListBuildAliasesRequestModel, entityToken string) (*ListBuildAliasesResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/ListBuildAliases", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &ListBuildAliasesResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ListBuildSummariesV2 lists summarized details of all multiplayer server builds for a title. Accepts tokens for title and if game client
// access is enabled, allows game client to request list of builds with player entity token.
// https://api.playfab.com/Documentation/Multiplayer/method/ListBuildSummariesV2
func ListBuildSummariesV2(settings *playfab.Settings, postData *ListBuildSummariesRequestModel, entityToken string) (*ListBuildSummariesResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/ListBuildSummariesV2", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &ListBuildSummariesResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ListCertificateSummaries lists multiplayer server game certificates for a title.
// https://api.playfab.com/Documentation/Multiplayer/method/ListCertificateSummaries
func ListCertificateSummaries(settings *playfab.Settings, postData *ListCertificateSummariesRequestModel, entityToken string) (*ListCertificateSummariesResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/ListCertificateSummaries", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &ListCertificateSummariesResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ListContainerImages lists custom container images for a title.
// https://api.playfab.com/Documentation/Multiplayer/method/ListContainerImages
func ListContainerImages(settings *playfab.Settings, postData *ListContainerImagesRequestModel, entityToken string) (*ListContainerImagesResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/ListContainerImages", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &ListContainerImagesResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ListContainerImageTags lists the tags for a custom container image.
// https://api.playfab.com/Documentation/Multiplayer/method/ListContainerImageTags
func ListContainerImageTags(settings *playfab.Settings, postData *ListContainerImageTagsRequestModel, entityToken string) (*ListContainerImageTagsResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/ListContainerImageTags", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &ListContainerImageTagsResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ListMatchmakingTicketsForPlayer list all matchmaking ticket Ids the user is a member of.
// https://api.playfab.com/Documentation/Multiplayer/method/ListMatchmakingTicketsForPlayer
func ListMatchmakingTicketsForPlayer(settings *playfab.Settings, postData *ListMatchmakingTicketsForPlayerRequestModel, entityToken string) (*ListMatchmakingTicketsForPlayerResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Match/ListMatchmakingTicketsForPlayer", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &ListMatchmakingTicketsForPlayerResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ListMultiplayerServers lists multiplayer server sessions for a build.
// https://api.playfab.com/Documentation/Multiplayer/method/ListMultiplayerServers
func ListMultiplayerServers(settings *playfab.Settings, postData *ListMultiplayerServersRequestModel, entityToken string) (*ListMultiplayerServersResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/ListMultiplayerServers", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &ListMultiplayerServersResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ListPartyQosServers lists quality of service servers for party.
// https://api.playfab.com/Documentation/Multiplayer/method/ListPartyQosServers
func ListPartyQosServers(settings *playfab.Settings, postData *ListPartyQosServersRequestModel, ) (*ListPartyQosServersResponseModel, error) {

    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/ListPartyQosServers", "", "")
    if err != nil {
        return nil, err
    }
    
    result := &ListPartyQosServersResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ListQosServersForTitle lists quality of service servers for the title. By default, servers are only returned for regions where a Multiplayer
// Servers build has been deployed.
// https://api.playfab.com/Documentation/Multiplayer/method/ListQosServersForTitle
func ListQosServersForTitle(settings *playfab.Settings, postData *ListQosServersForTitleRequestModel, entityToken string) (*ListQosServersForTitleResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/ListQosServersForTitle", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &ListQosServersForTitleResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ListServerBackfillTicketsForPlayer list all server backfill ticket Ids the user is a member of.
// https://api.playfab.com/Documentation/Multiplayer/method/ListServerBackfillTicketsForPlayer
func ListServerBackfillTicketsForPlayer(settings *playfab.Settings, postData *ListServerBackfillTicketsForPlayerRequestModel, entityToken string) (*ListServerBackfillTicketsForPlayerResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Match/ListServerBackfillTicketsForPlayer", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &ListServerBackfillTicketsForPlayerResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ListTitleMultiplayerServersQuotaChanges list all server quota change requests for a title.
// https://api.playfab.com/Documentation/Multiplayer/method/ListTitleMultiplayerServersQuotaChanges
func ListTitleMultiplayerServersQuotaChanges(settings *playfab.Settings, postData *ListTitleMultiplayerServersQuotaChangesRequestModel, entityToken string) (*ListTitleMultiplayerServersQuotaChangesResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/ListTitleMultiplayerServersQuotaChanges", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &ListTitleMultiplayerServersQuotaChangesResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ListVirtualMachineSummaries lists virtual machines for a title.
// https://api.playfab.com/Documentation/Multiplayer/method/ListVirtualMachineSummaries
func ListVirtualMachineSummaries(settings *playfab.Settings, postData *ListVirtualMachineSummariesRequestModel, entityToken string) (*ListVirtualMachineSummariesResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/ListVirtualMachineSummaries", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &ListVirtualMachineSummariesResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// RemoveMember remove a member from a lobby.
// https://api.playfab.com/Documentation/Multiplayer/method/RemoveMember
func RemoveMember(settings *playfab.Settings, postData *RemoveMemberFromLobbyRequestModel, entityToken string) (*LobbyEmptyResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Lobby/RemoveMember", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &LobbyEmptyResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// RequestMultiplayerServer request a multiplayer server session. Accepts tokens for title and if game client access is enabled, allows game client
// to request a server with player entity token.
// https://api.playfab.com/Documentation/Multiplayer/method/RequestMultiplayerServer
func RequestMultiplayerServer(settings *playfab.Settings, postData *RequestMultiplayerServerRequestModel, entityToken string) (*RequestMultiplayerServerResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/RequestMultiplayerServer", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &RequestMultiplayerServerResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// RolloverContainerRegistryCredentials rolls over the credentials to the container registry.
// https://api.playfab.com/Documentation/Multiplayer/method/RolloverContainerRegistryCredentials
func RolloverContainerRegistryCredentials(settings *playfab.Settings, postData *RolloverContainerRegistryCredentialsRequestModel, entityToken string) (*RolloverContainerRegistryCredentialsResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/RolloverContainerRegistryCredentials", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &RolloverContainerRegistryCredentialsResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ShutdownMultiplayerServer shuts down a multiplayer server session.
// https://api.playfab.com/Documentation/Multiplayer/method/ShutdownMultiplayerServer
func ShutdownMultiplayerServer(settings *playfab.Settings, postData *ShutdownMultiplayerServerRequestModel, entityToken string) (*EmptyResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/ShutdownMultiplayerServer", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SubscribeToLobbyResource subscribe to lobby resource notifications.
// https://api.playfab.com/Documentation/Multiplayer/method/SubscribeToLobbyResource
func SubscribeToLobbyResource(settings *playfab.Settings, postData *SubscribeToLobbyResourceRequestModel, entityToken string) (*SubscribeToLobbyResourceResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Lobby/SubscribeToLobbyResource", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &SubscribeToLobbyResourceResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UnsubscribeFromLobbyResource unsubscribe from lobby notifications.
// https://api.playfab.com/Documentation/Multiplayer/method/UnsubscribeFromLobbyResource
func UnsubscribeFromLobbyResource(settings *playfab.Settings, postData *UnsubscribeFromLobbyResourceRequestModel, entityToken string) (*LobbyEmptyResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Lobby/UnsubscribeFromLobbyResource", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &LobbyEmptyResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UntagContainerImage untags a container image.
// https://api.playfab.com/Documentation/Multiplayer/method/UntagContainerImage
func UntagContainerImage(settings *playfab.Settings, postData *UntagContainerImageRequestModel, entityToken string) (*EmptyResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/UntagContainerImage", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateBuildAlias creates a multiplayer server build alias.
// https://api.playfab.com/Documentation/Multiplayer/method/UpdateBuildAlias
func UpdateBuildAlias(settings *playfab.Settings, postData *UpdateBuildAliasRequestModel, entityToken string) (*BuildAliasDetailsResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/UpdateBuildAlias", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &BuildAliasDetailsResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateBuildName updates a multiplayer server build's name.
// https://api.playfab.com/Documentation/Multiplayer/method/UpdateBuildName
func UpdateBuildName(settings *playfab.Settings, postData *UpdateBuildNameRequestModel, entityToken string) (*EmptyResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/UpdateBuildName", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateBuildRegion updates a multiplayer server build's region. If the region is not yet created, it will be created
// https://api.playfab.com/Documentation/Multiplayer/method/UpdateBuildRegion
func UpdateBuildRegion(settings *playfab.Settings, postData *UpdateBuildRegionRequestModel, entityToken string) (*EmptyResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/UpdateBuildRegion", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateBuildRegions updates a multiplayer server build's regions.
// https://api.playfab.com/Documentation/Multiplayer/method/UpdateBuildRegions
func UpdateBuildRegions(settings *playfab.Settings, postData *UpdateBuildRegionsRequestModel, entityToken string) (*EmptyResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/UpdateBuildRegions", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateLobby update a lobby.
// https://api.playfab.com/Documentation/Multiplayer/method/UpdateLobby
func UpdateLobby(settings *playfab.Settings, postData *UpdateLobbyRequestModel, entityToken string) (*LobbyEmptyResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Lobby/UpdateLobby", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &LobbyEmptyResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UploadCertificate uploads a multiplayer server game certificate.
// https://api.playfab.com/Documentation/Multiplayer/method/UploadCertificate
func UploadCertificate(settings *playfab.Settings, postData *UploadCertificateRequestModel, entityToken string) (*EmptyResponseModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/MultiplayerServer/UploadCertificate", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &EmptyResponseModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}



